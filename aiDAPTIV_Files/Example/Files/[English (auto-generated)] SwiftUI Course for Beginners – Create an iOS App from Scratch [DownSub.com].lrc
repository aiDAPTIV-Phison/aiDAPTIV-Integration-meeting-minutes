[00:00.16]Learn how to create a complete iOS app
[00:02.80]from scratch using Swift UI and Xcode.
[00:06.16]In this tutorial, Carlos will teach you
[00:08.16]to build a featurerich movie and TV
[00:10.55]browsing app with a dynamic home screen,
[00:13.20]powerful search, and detail screens that
[00:15.83]play YouTube trailers. You'll also
[00:18.00]implement a download manager to save
[00:20.56]titles for offline viewing using Swift
[00:23.68]data. By integrating the movie database
[00:26.08]and YouTube APIs, this project provides
[00:28.80]excellent hands-on practice with Swift
[00:30.80]UI API integration and modern data
[00:33.28]storage. Hey everyone, Carlos from
[00:35.92]Blossom Build back with a new exciting
[00:38.07]project. We'll be building a complete
[00:40.16]iOS app from scratch using Swift UI and
[00:43.12]Xcode.
[00:44.87]Before we look at the app, I want to
[00:46.96]give a quick shout out to Ommer. I
[00:49.52]originally learned how to build this app
[00:50.87]by watching Omer's YouTube channel. He
[00:53.28]built it using UI kit and I learned a
[00:55.36]great deal from him. Please check out
[00:57.12]his channel and show some support.
[01:00.23]This is a similar app but updated with
[01:02.16]Swift UI, Swift data, and the latest iOS
[01:05.11]version. There are also a few more added
[01:07.92]features. We're going to try to keep the
[01:10.24]app updated so it can remain a valuable
[01:12.40]resource.
[01:13.92]Let's take a look at it. I named it
[01:15.84]Blossom Movie.
[01:18.96]First, opening the app, you can see it
[01:21.04]has four tabs on the bottom toolbar. The
[01:24.00]home screen features a hero title that
[01:26.08]changes whenever the app is opened.
[01:29.04]Scrolling down, the app shows trending
[01:31.20]movies and TV shows, as well as top
[01:33.68]rated movies and TV shows.
[01:37.20]We're able to scroll vertically to get
[01:38.96]more titles that are instantly loaded.
[01:41.52]This is possible by working with the
[01:43.04]movie database API.
[01:45.75]Clicking on a title opens a detail
[01:47.52]screen.
[01:49.68]This screen contains a name,
[01:51.20]description, and a YouTube trailer. This
[01:54.32]project also works with the YouTube API.
[01:57.60]Navigating to upcoming,
[01:59.92]we see a list of upcoming movies in a
[02:01.92]vertical list this time. We can scroll
[02:04.56]down to quickly get more titles.
[02:07.28]Selecting any title brings up the title
[02:09.36]detail screen.
[02:11.92]Moving on to search.
[02:14.16]This is my favorite part of the app. The
[02:16.72]titles on a grid this time and we can
[02:18.95]conduct a search. For example, I can
[02:21.76]search for Harry Potter
[02:26.64]and instantly get results.
[02:30.56]We can cancel
[02:32.64]and the default list displays.
[02:35.51]The button up top can be pressed to
[02:37.51]switch the search to TV shows. I'll
[02:40.64]search my favorite TV show, Breaking
[02:42.40]Bad.
[02:46.23]Finally, we have the download tab.
[02:49.59]Currently, this message is displayed
[02:51.84]because we have no downloads.
[02:54.48]If we download a title
[02:58.16]and go back to the download tab,
[03:00.95]it displays right away.
[03:03.44]Closing and reopening the app does not
[03:05.12]remove it from the download tab.
[03:09.28]We can instead swipe left to delete the
[03:11.20]file.
[03:14.00]This is a great app to build for some
[03:15.51]practice with Swift UI APIs, Swift data,
[03:18.48]and more. I'm excited to start this
[03:20.80]journey with you. We're ready to start
[03:23.12]this project. The first step, of course,
[03:25.59]is to create it. Before that, please
[03:28.00]make sure your Xcode and Mac OS are
[03:30.23]updated. I'll select create new project.
[03:34.64]We're going to be making an iOS
[03:36.15]application.
[03:38.00]Next,
[03:39.51]for the product name, let's go with
[03:41.36]Blossom Movie. I do have myself as a
[03:44.40]team. To do this, you'll have to log
[03:47.44]into your Apple ID. You can also use
[03:50.00]none.
[03:51.92]The organization identifier is a domain
[03:54.08]name of your company backwards. I have
[03:56.31]mine as Blossom Build, but feel free to
[03:58.48]use yours or make one up. Interface has
[04:01.28]to be Swift UI. language swift testing
[04:05.59]system none and storage none. We'll be
[04:09.04]using swift data as a storage. However,
[04:11.92]if we select it, the project will create
[04:14.23]unnecessary code. It's easier to add
[04:16.88]later. Hit next.
[04:21.51]You can save this project anywhere you
[04:23.19]like. Select create once you got your
[04:25.52]folder.
[04:37.28]We have our project created and the
[04:39.19]famous hello world pops up. I'll do
[04:41.68]command control F to go full screen.
[04:44.88]I'll also make my canvas smaller to
[04:47.19]allow more space for the code.
[04:51.68]I do want to write just a bit of code to
[04:53.75]get our feet wet. A good place to start
[04:56.40]is to create the four tabs our app will
[04:58.72]use. In the content view, we can delete
[05:02.00]from padding up to vstack.
[05:06.47]Instead, type tab view
[05:09.19]open curly brace and enter. Inside the
[05:12.63]tab view curly braces, we need to define
[05:15.12]our tabs. Type tab open parenthesis.
[05:20.32]There are two parameters here. First, a
[05:23.36]string for the tab name. Quote, type in
[05:26.40]home quote again, comma. The second
[05:30.56]parameter is the icon image we want to
[05:32.47]use. We're going to be using the free SF
[05:35.36]symbols built into Xcode.
[05:38.88]Type system and Xcode is recommending
[05:41.60]the correct name. Press tab to
[05:43.68]autocomplete.
[05:48.32]quote type house close quote close
[05:51.75]parenthesis
[05:53.36]open curly brace and enter.
[05:57.36]Inside these braces, we need to define
[05:59.84]the content of this tab. A text display
[06:03.28]home
[06:06.40]would do just fine. That is our first
[06:09.28]tab complete. Notice our preview updated
[06:12.08]correctly.
[06:14.40]For efficiency, let's copy our tab by
[06:16.80]highlighting and pressing command C.
[06:20.47]Paste it three times with command V.
[06:25.52]The second tab will be called upcoming.
[06:30.63]We can change system image to play.
[06:32.72]Circle.
[06:37.12]The text will also change to upcoming.
[06:43.03]The third tab is search
[06:46.88]system image will be magnifying glass
[06:54.16]text of course is also search.
[06:58.72]Finally we have download
[07:04.00]system image is arrowd
[07:07.19]down.2 two line
[07:10.88]text is also download.
[07:15.12]I think that looks pretty good for now.
[07:17.44]We can click through the different tabs
[07:18.80]in our canvas to confirm.
[07:23.28]We build our bottom toolbar containing
[07:24.96]four tabs using pretty simple code.
[07:28.00]Swift UI makes it that easy. This is a
[07:30.88]great place to stop. Awesome work.
[07:34.80]We have our tab view working properly.
[07:37.19]Before we get into more Swift UI, a
[07:39.68]quick topic. Currently, our content view
[07:42.72]contains hard-coded strings. An example
[07:45.12]is the home string in our first tab.
[07:47.59]While hard-coded strings are convenient,
[07:49.68]they can lead to typos and be harder to
[07:51.84]maintain when the application grows.
[07:53.91]This is not going to be a published app,
[07:55.84]but I do believe in building good coding
[07:57.68]habits. Therefore, we'll create a
[08:00.40]constant file and put all the strings
[08:02.56]there. To begin, use a shortcut command
[08:06.16]N to make a new file. Select Swift file.
[08:10.31]Next,
[08:11.91]call this file constants.
[08:15.44]Create.
[08:18.63]Under import foundation, type strr
[08:22.08]constants.
[08:24.08]If the editor recommends the correct
[08:25.59]syntax, press tab to complete like I
[08:28.56]just did. Time to make our first string.
[08:31.68]Static. Let home string
[08:35.44]equals home.
[08:39.20]Static allows this string to be accessed
[08:41.03]across the app. Let means the string
[08:43.44]won't change within the program. Of
[08:46.00]course, we can still change it in the
[08:47.92]code. We'll keep going. Static let
[08:52.64]upcoming string equals upcoming.
[08:57.12]static let search string equals search
[09:03.36]static let download string
[09:07.76]equals download.
[09:10.24]It's also good to be specific when
[09:12.00]naming variables. Navigate back to
[09:14.56]content view,
[09:17.51]delete home,
[09:21.36]instead type constants
[09:24.24]home string.
[09:26.32]Do the same for the home inside text.
[09:34.95]Upcoming is next. Delete and replace
[09:37.12]both occurrences.
[09:39.04]constants
[09:41.44]upcoming string.
[09:44.72]Constants
[09:46.72]do upcoming string.
[09:50.48]Next to search
[09:53.12]constants
[09:54.80]dot search string
[09:58.08]constants
[09:59.92]search string.
[10:02.39]Finally download
[10:05.76]constants.d
[10:08.24]download string
[10:11.60]constants.d downloadd download string.
[10:14.39]We also want to put the system image
[10:16.07]names in our constants file. Go back to
[10:18.80]constants.
[10:20.80]Make some space. Static let home icon
[10:24.95]string equals house
[10:29.68]static let
[10:31.76]upcoming
[10:33.92]icon string equals
[10:36.88]play dot circle
[10:41.51]static lamp. Search icon string equals
[10:45.20]magnifying glass
[10:48.00]static lamp. Download icon string equals
[10:53.60]arrow down.2
[10:56.07]line. Back to our content view one more
[10:58.88]time.
[11:04.24]Replace house with constants
[11:09.44]dot home icon string.
[11:13.92]Playout circle with constants
[11:17.92]dot upcoming icon string.
[11:22.16]Magnifying glass with constants
[11:26.00]dot search icon string
[11:29.04]and arrow.down.2.line
[11:31.20]with constants
[11:33.12]dot
[11:34.24]download icon string.
[11:37.27]Not the most exciting work, but it's
[11:39.36]good for us in the long run. One more
[11:42.00]benefit to doing this is easier
[11:43.92]migration to different languages.
[11:46.80]We'll stop here, but I promise to have
[11:49.04]exciting Swifty action next time.
[11:52.72]We're effectively following good stream
[11:54.48]practices. It'll be easier to apply for
[11:57.04]the rest of our app. Now, we can start
[11:59.04]working on the home screen. I do want
[12:00.80]our content view to stay clean and just
[12:02.80]hold the tab view. It'll get big fast if
[12:05.44]we code all the screens on it. Let's
[12:07.44]make a new Swift UI file for the home
[12:09.12]screen. Press command N. Swift UI view.
[12:13.92]Next,
[12:16.00]home view.
[12:18.00]Create.
[12:23.44]The home screen first features a hero
[12:25.27]title. All the images used for this app
[12:28.24]are inside the internet as URLs. For
[12:31.27]testing, we can define a temporary image
[12:34.16]at the top of our home view. Hit enter
[12:37.04]after the first curly brace twice.
[12:40.48]Back to line 11
[12:42.95]bar hero test title equals quotes.
[12:49.12]Navigate to constants.
[12:52.16]After our last string, hit enter a
[12:54.63]couple times.
[12:56.39]static let test title URL equals single
[13:02.56]quote.
[13:04.24]I'll paste a sample URL. It will be in
[13:06.72]the video description. Please copy and
[13:08.95]paste it as well. Go back to home view.
[13:13.76]Replace the empty string with constants
[13:17.12]test title URL.
[13:20.00]Now we can build our view. Delete the
[13:22.48]text view.
[13:25.60]Type vstack with braces.
[13:29.04]vstack aligns all the views inside its
[13:31.04]braces vertically.
[13:33.27]Our image needs to be loaded
[13:34.56]asynchronously because it's coming from
[13:36.88]online. This means it loads on a
[13:39.92]separate thread, not the main thread.
[13:42.56]That's for our UI. Swift UI has a great
[13:45.68]tool called async image.
[13:48.63]Start typing async.
[13:51.04]Select the second one and press enter.
[13:54.24]Async image takes a URL, but our hero
[13:56.95]test title is a string. We can easily
[13:59.60]convert it by typing URL in all caps
[14:02.56]open parenthesis
[14:04.48]string colon hero test title.
[14:09.60]We're using Beetlejuice as our practice
[14:11.36]title. I honestly like the poster art.
[14:14.32]The image is pretty big right now. In
[14:16.63]order to adjust it, put braces at the
[14:18.95]end of our async image.
[14:21.51]After the first brace, type image in.
[14:27.04]This puts our async image inside a
[14:29.19]variable called image.
[14:31.27]We can put modifiers on this variable to
[14:33.36]adjust it. Before we do that, we have to
[14:36.80]define a placeholder while the image
[14:39.04]loads. After the async image curly
[14:41.92]braces,
[14:43.44]type place and hit enter to
[14:46.07]autocomplete.
[14:47.92]In the placeholder braces, we can type
[14:50.56]progress view.
[14:53.12]As the image loads, progress view, which
[14:56.24]contains a progress circle, will show.
[14:59.83]Let's go back inside our async image
[15:01.51]braces.
[15:03.19]Type image.resizable.caleto
[15:06.80]fit.
[15:08.88]These two things we just added are
[15:10.32]called modifiers.
[15:12.32]Modifiers allow us to change our views.
[15:15.19]In this case, we're allowing the image
[15:17.51]to be resizable and fitting it in our
[15:19.92]parent view without distortion.
[15:22.80]Modifiers are usually in separate lines
[15:24.80]so they can stand out. Put your cursor
[15:27.68]right after the Ean image and press
[15:30.24]enter.
[15:32.24]I'll press escape to dismiss that
[15:33.92]suggestion.
[15:35.76]Press enter again after the resizable
[15:38.00]closing parenthesis.
[15:41.36]This is looking pretty good. I also
[15:43.68]think it's a good place to stop. Great
[15:45.92]job on this one. Our hero test title is
[15:48.95]displayed correctly. Under the hero
[15:51.12]title, we need two buttons. One button
[15:54.16]to play the trailer and another to
[15:56.16]download the title. Make some space
[15:58.24]after the placeholder braces.
[16:01.04]These two buttons should be side by
[16:02.56]side. To do this, we can type hstack
[16:07.19]with braces.
[16:09.19]htack orders its views horizontally.
[16:12.72]Inside our H stack, type button with
[16:16.24]braces.
[16:18.00]After the closing brace, type label and
[16:21.92]hit tab to autocomplete.
[16:25.04]In the first set of braces, we'll tell
[16:27.36]the button what action to perform. The
[16:29.83]second set is for design. Before that,
[16:33.04]we need to define a string. Navigate to
[16:35.75]constants.
[16:37.44]Make some space after the download
[16:39.75]string.
[16:41.51]static let
[16:44.39]play string equals play.
[16:49.12]Lucky for us, the download string is
[16:51.27]already defined. Navigate back to home
[16:54.07]view.
[16:55.83]Inside label, type text
[16:59.92]constants
[17:01.44]dot play string.
[17:04.55]We can now see a small play button in
[17:06.95]our preview. Copy and paste the button
[17:09.83]code to make another one. Change the
[17:13.03]second text to constants dot download
[17:16.72]string. These buttons work, but they
[17:20.07]need some design. We can add some
[17:22.48]modifiers. After the play string text,
[17:25.76]hit enter and type dot frame.
[17:29.84]The first option is in what we need.
[17:32.24]Press your right arrow key for more
[17:34.08]options. Select the option that contains
[17:36.96]width and height.
[17:39.52]The frame modifier adds an invisible
[17:41.44]frame with a specified size, but 100 for
[17:45.03]the width and 50 for the height.
[17:48.96]Press enter after the closing
[17:50.32]parenthesis and add dot bold. This bolds
[17:54.48]the text. A border would look nice
[17:56.96]around the button. Press enter
[18:00.55]dot background.
[18:03.03]We want the one that has content.
[18:05.76]Press enter for braces.
[18:09.36]Inside the background braces, input
[18:12.79]rounded rectangle.
[18:16.40]Select the option with corner radius and
[18:19.28]style.
[18:21.20]Use 20 for the radius and dot continuous
[18:25.36]for style.
[18:27.36]This makes a rounded rectangle with the
[18:29.60]radius of 20, but our text is covered.
[18:33.03]We can use the stroke modifier to just
[18:35.60]keep the border. After the closing
[18:37.84]parenthesis, press enter.
[18:41.12]Type dot stroke.
[18:44.72]Select the one with line width five.
[18:48.72]Much better. The button looks pretty
[18:51.12]good. But I would like to add our custom
[18:53.67]color. Navigate to assets.
[18:57.28]Right click.
[18:59.28]New color set.
[19:01.44]But in border,
[19:03.84]enter. Open the inspector.
[19:07.67]Change appearances to none.
[19:10.55]This color will be the same for dark and
[19:13.20]light mode. Click where it says
[19:15.36]universal.
[19:17.20]Show color panel.
[19:19.52]Type in 34 B4 6C for the hex color.
[19:26.96]Enter.
[19:28.64]That's blossom build green.
[19:31.03]Close the color panel. While we're here,
[19:34.40]let's add one more color. Right click,
[19:38.40]new color set,
[19:40.55]button, text,
[19:42.72]enter.
[19:44.40]Make sure appearance is any dark.
[19:47.67]Click on any appearance.
[19:50.00]Show color panel.
[19:52.24]Six zeros. 1 2 3 4 5 6.
[19:57.20]Enter.
[19:58.72]Close the color panel.
[20:00.79]When the app is in light mode, the
[20:02.96]button text color should be black. In
[20:05.76]dark mode, the color should be white.
[20:09.28]This is a great place to stop.
[20:11.36]Outstanding work.
[20:13.76]The colors are ready to go. We just need
[20:16.24]to apply them to our buttons. Navigate
[20:18.96]back to home view.
[20:21.67]In our play text after frame, hit enter.
[20:27.28]Type dot foreground.
[20:30.72]Press enter on foreground style.
[20:34.15]Use dot button text for the argument.
[20:39.12]This modifier defines the text color. A
[20:42.08]quick reminder, button text is black for
[20:44.64]light mode and white for dark mode. We
[20:47.76]can test this by selecting canvas device
[20:49.67]settings.
[20:51.52]Toggle color scheme
[20:53.67]dark appearance.
[20:55.67]The plate text changes to white.
[20:58.88]I'll toggle back to light mode for now.
[21:01.76]Let's add our border color. In the
[21:03.91]stroke modifier before line width, add a
[21:07.60]comma.
[21:09.28]Left arrow key once.
[21:11.76]Dot button border.
[21:14.88]I'd say the play button looks much
[21:16.88]better. We can't leave the download
[21:18.96]button hanging. It would be easy to copy
[21:21.44]and paste the modifiers to the download
[21:23.67]button. However, this brings us to our
[21:26.88]next coding principle. The famous don't
[21:30.08]repeat yourself or dry idea. Dry is all
[21:34.15]about promoting efficiency and reducing
[21:36.48]redundancy.
[21:38.08]If we the developers are going to use
[21:40.79]code more than once, we should only
[21:43.44]write it once. Of course, as with any
[21:46.96]principle, try to follow the best you
[21:49.12]can. Don't lose any sleep if you can't
[21:52.15]use it 100% of the time.
[21:54.64]This button style is used a few times in
[21:57.20]the project. Hence, let's write the code
[22:00.32]once and use it more. Notice the
[22:03.28]modifiers are on text, not the button
[22:05.76]itself. Therefore, we can create a
[22:08.96]function that automatically applies
[22:10.64]these modifiers to a text. Highlight the
[22:13.76]modifiers.
[22:15.60]Copy with command C.
[22:18.24]Navigate to constants
[22:20.64]at the top. import swift UI.
[22:26.00]This import is needed because we'll be
[22:28.15]calling Swift UI elements. Make some
[22:31.03]space after the closing braces.
[22:33.84]Type extension
[22:36.15]text with curly braces.
[22:39.84]Extension allows us to add functionality
[22:42.15]to an already existing type without
[22:44.64]modifying the original. Inside the
[22:46.72]braces, type funk
[22:50.00]ghost button
[22:52.64]parenthesis
[22:54.55]return arrow some view with braces.
[23:00.24]This creates a function called ghost
[23:02.48]button that returns a view. Inside the
[23:06.15]braces, type self.
[23:09.12]Self refers to the current instance
[23:11.20]where the function is located.
[23:13.67]The function is located inside an
[23:15.20]extension of text. Therefore, self
[23:18.40]refers to text. Hit enter after self and
[23:22.00]paste the modifiers.
[23:24.24]Usually, when a function returns a
[23:26.55]value, you have to type return at the
[23:29.28]end. However, because self is the only
[23:32.96]thing written and matches the return
[23:35.03]type, it automatically returns after
[23:38.24]applying the modifiers.
[23:40.55]Steer back to home view.
[23:43.28]delete all the modifiers in our play
[23:45.20]text.
[23:46.72]Instead, type dot ghost button.
[23:52.08]Go down to our closing download text
[23:54.00]parenthesis.
[23:55.91]Enter
[23:57.60]dot ghost button.
[24:00.24]Our custom function ghost button applies
[24:03.44]all the modifiers we defined.
[24:06.00]If you ever need to see the source code
[24:07.44]of a function, hold command and click on
[24:10.64]it. very helpful for looking under the
[24:13.36]hood. Back to home view. The code looks
[24:17.60]pretty and most importantly, it was easy
[24:20.24]to use. This is because we took the time
[24:23.36]to make it more efficient. Go ahead and
[24:26.08]click on the buttons for a quick test.
[24:29.03]Notice the whole button clicks when
[24:31.76]tapped.
[24:33.36]Switching to dark mode. It looks
[24:35.91]awesome.
[24:37.52]This is a great place to stop and take a
[24:39.76]break. Outstanding job again. I can't
[24:43.27]wait to see you in the next one.
[24:46.00]The home screen is really coming
[24:47.44]together. We have a hero title and two
[24:50.40]buttons underneath. Our next step is to
[24:52.55]make the horizontal list under the
[24:54.64]buttons. There'll be four lists total.
[24:57.76]These lists will be trending movies,
[25:01.03]trending TV shows, top rated movies, and
[25:04.79]top rated TV shows. Keeping the dry
[25:07.60]method in mind, we'll create one file
[25:10.88]and reuse it. First thing we need is
[25:14.40]more test images.
[25:16.48]Navigate to constants.
[25:19.20]Make some space after test title URL.
[25:22.88]I'll make sure to include these strings
[25:24.55]in a description. Please copy and paste
[25:27.20]them.
[25:28.79]Static let test title URL 2 equals paste
[25:36.64]static lat test title URL 3 equals
[25:42.72]I'll grab the string
[25:46.08]paste.
[25:48.24]While we're here, let's also make a
[25:50.40]trending movie string. Press enter after
[25:53.12]play string
[25:55.52]static. Let trending movie string equals
[26:01.36]trending movies.
[26:03.52]Great work. Use command N to make a new
[26:06.08]file. Swift UI view. Next.
[26:10.88]Horizontal.
[26:13.36]List view. Create.
[26:17.84]Let it load.
[26:20.48]Press enter twice after the first brace.
[26:23.76]Up arrow once.
[26:25.91]Let header equals constants dot trending
[26:30.64]movie string
[26:32.55]bar titles equals bracket constants dot
[26:38.55]test title URL comma constants dot test
[26:43.03]title URL 2 comma constants dot test
[26:47.67]title URL 3. We define two variables
[26:50.64]here. Header is our trending movie
[26:52.96]string. Let was used because it won't
[26:56.15]change. Titles is an array of strings
[26:59.36]currently holding our three test titles.
[27:02.08]Bar was used because the list might
[27:04.40]change when the data refreshes.
[27:07.67]Delete the hello world text.
[27:11.12]Instead, type BS stack
[27:13.76]down arrow to the one that has alignment
[27:15.27]and more options. Right arrow.
[27:18.79]Select the one with alignment and
[27:20.08]content.
[27:21.76]For alignment, put dole leading tab. Hit
[27:25.67]enter to get braces.
[27:28.32]This vstack will align all its views to
[27:30.48]the left of the phone inside the braces
[27:33.67]text header.
[27:36.79]Add the modifier font.title.
[27:41.44]This makes the text bigger. Under the
[27:44.00]text, type scroll view
[27:47.27]with parentheses and curly braces.
[27:50.40]Scroll view allows us to scroll through
[27:51.91]views that exceed the screen capacity.
[27:54.96]Inside the parenthesis, put dot
[27:57.20]horizontal.
[27:58.72]This allows our views to scroll
[28:00.08]horizontally.
[28:01.91]In the braces, type lazy hstack with
[28:06.24]braces.
[28:07.76]Lazy htack only loads the views when
[28:10.55]needed. inside lazy hstack for each
[28:15.91]titles
[28:18.15]open brace title in enter three times
[28:23.84]for each is a handy tool that loops
[28:26.00]through a list. It also gives us access
[28:28.55]to each element. We're getting an error
[28:31.60]because each element needs to have an
[28:33.03]ID. Since each string is different, we
[28:36.55]can use the string itself as an ID.
[28:39.36]after titles
[28:41.60]comma
[28:43.67]id colon backslash self.
[28:47.76]We can now access each element in our
[28:49.52]titles array. Each element is
[28:52.00]represented by the title variable after
[28:54.15]the braces. Inside for each, we'll use
[28:57.76]async image.
[29:00.24]Select the one with the URL URL
[29:03.67]string
[29:05.20]title.
[29:07.12]That loads our images, but we
[29:08.88]desperately need some modifiers.
[29:11.36]Open brace image in enter three times.
[29:16.39]After the brace, type place tab progress
[29:21.44]view in the placeholder. Back inside
[29:24.79]async image
[29:26.72]image entertizable.caleto
[29:31.12]fit.
[29:32.72]We've seen these modifiers in our home
[29:34.39]view. The difference is we're going to
[29:37.12]add a frame to better contain it. After
[29:39.84]our placeholder
[29:42.39]frame,
[29:44.24]right arrow, select the one with width
[29:46.96]and height.
[29:48.96]Do 120 for width and 200 for height.
[29:53.20]All right, we're almost there. A frame
[29:56.24]is needed on the parent vstack itself.
[29:59.27]There are quite a few closing braces,
[30:01.20]but if you double click on the leading
[30:02.72]BS stack brace, Xcode will show you
[30:05.44]where the closing brace is. After the
[30:08.15]closing brace,
[30:10.00]enter dot frame. Right arrow only height
[30:14.79]this time. Do 250.
[30:18.24]This constricts the view to have a max
[30:20.55]height of 250.
[30:23.20]We're pretty close to the edge. To fix
[30:25.91]this, we can add a padding modifier.
[30:29.52]This creates space. The default is 16
[30:32.39]points. Put 10 in the parenthesis for
[30:35.27]less space. Wow, we did a lot in this
[30:38.96]video. Great work as usual. Let's take a
[30:42.55]break and I can't wait to see you in the
[30:44.64]next one.
[30:46.48]We're almost done with the horizontal
[30:48.00]list view. Before we use it in our home
[30:50.55]view, just a few final details.
[30:53.67]To begin, after the image scale to fit
[30:56.24]modifier, add the clip shape modifier.
[31:00.15]Inside the parenthesis, type rounded
[31:02.79]rectangle.
[31:05.12]Select the one with corner radius.
[31:07.76]Use 10.
[31:10.32]This modifier gives our images nice
[31:12.15]rounded corners. Slightly more modern
[31:14.64]looking in my opinion.
[31:17.12]Next, I would like header to be dynamic.
[31:20.39]If we use the view now, header can only
[31:22.88]be trending movies. This was great for
[31:25.44]testing. However, our view is finished
[31:29.12]and ready to be versatile.
[31:31.52]To do that, delete everything after
[31:33.60]header.
[31:36.24]Instead, type colon space string.
[31:40.72]This allows us to define a string for
[31:42.39]header when calling the view. Very
[31:45.20]helpful since we'll have four different
[31:47.03]types of lists.
[31:49.12]There's an error in the file because our
[31:51.51]preview needs an argument for header.
[31:54.00]Scroll down. Click on the error. Select
[31:57.51]fix.
[31:59.03]Click on the string. Type constants.
[32:02.88]Trending movie string.
[32:05.27]This wraps up our horizontal list view.
[32:08.00]Before we put it in our home screen,
[32:10.08]navigate to constants. Make some space
[32:13.03]after trending movie string.
[32:15.76]Let's define the rest of our headers.
[32:18.32]Static L trending TV string equals
[32:24.96]trending TV.
[32:28.39]Static L top rated movie string equals
[32:34.08]top rated movies.
[32:36.39]Static L top rated TV string equals top
[32:43.12]rated TV.
[32:45.76]Steer to home view.
[32:48.88]We want these titles after our buttons.
[32:51.51]Double click on the starting hstack
[32:53.44]brace to find the closing one. Make some
[32:56.88]space after the closing brace.
[33:00.00]Horizontal list view with header
[33:03.60]constants. trending movie string.
[33:08.15]Copy that line.
[33:12.24]Paste three times.
[33:15.44]Change the second one to
[33:16.55]constants.trending
[33:18.79]TV string.
[33:20.72]The third one to constants.toprated
[33:25.36]movie string. And the last one a
[33:28.08]constants.toprated
[33:30.00]TV string.
[33:31.84]The horizontal list are displaying
[33:33.67]correctly with the right headers.
[33:36.24]However, our home view doesn't look the
[33:38.39]best. This is because the number of
[33:40.88]views exceed the phone screen. To fix
[33:44.48]this, we can add a scroll view to our
[33:47.03]parent view. This can easily be done by
[33:49.76]scrolling up, right clicking on our
[33:52.32]vstack,
[33:54.08]select embedded,
[33:56.24]scroll view.
[33:59.03]Much better. While we're here, we should
[34:02.55]change the vstack to lazy vstack.
[34:08.72]Lazy vstack is best here as the views
[34:11.44]will load when they are needed. The home
[34:14.48]view layout is really close to being
[34:16.00]done. To finish up, I want to improve
[34:19.11]the hero title slightly.
[34:21.44]If we click on an empty line and hit
[34:23.83]space on our keyboard,
[34:25.83]this makes the view reload.
[34:28.32]Watching the hero title, it kind of just
[34:31.11]pops up. A frame modifier will fix this.
[34:34.96]We're going to need the size of the
[34:36.48]screen to pull this off. This can be
[34:39.67]done by using geometry reader. Right
[34:42.32]click on scroll view embed
[34:46.00]geometry reader. After the braces,
[34:49.76]go n. Navigate to the placeholder
[34:52.72]closing brace.
[34:54.72]Entertrame.
[34:57.04]Right arrow. Select the one with width
[34:59.35]and height.
[35:01.44]For width, type go.
[35:04.16]D.width.
[35:06.00]For height, do go.
[35:11.44]This makes the frame the size of the
[35:13.20]screen. We can make this better by
[35:15.68]adjusting the height. Type times
[35:19.76]0.85.
[35:22.40]To summarize, we embedded scroll view
[35:25.04]into geometry reader. Geometry reader
[35:27.68]got the available screen space minus the
[35:30.00]safe space. We put the frame of our hero
[35:32.88]title to the full width of our available
[35:35.28]space. However, we only want the height
[35:38.40]to be 85% of the available space. Now,
[35:41.68]if we test
[35:44.24]the hero title doesn't jump on screen.
[35:47.28]As mentioned before, home view is close
[35:49.76]to being finished. Just a few more final
[35:52.32]touches, but we'll do them in the next
[35:54.40]video. Thank you for joining us. Can't
[35:57.35]wait to see you in the next one.
[36:00.00]We have all the elements on our home
[36:01.76]view. To finish, I'd like to add a
[36:04.72]gradient between the hero image and
[36:06.96]space after it. The first step is to
[36:09.52]define a new color. Navigate to assets,
[36:13.35]right click, new color set, gradients.
[36:18.88]In light mode, the gradient should be
[36:20.88]white to match the space after our hero
[36:22.96]title. Thus, in dark mode, the gradient
[36:26.64]should be black. Select dark.
[36:30.16]Open the inspector.
[36:32.16]Color set.
[36:34.07]Show color panel.
[36:36.64]Six zeros. 1 2 3 4 5 6. Enter. Close the
[36:42.96]color panel. Close inspector.
[36:46.48]Go back to home view.
[36:49.83]Hit enter after the scale to fit
[36:51.68]modifier
[36:53.52]dot overlay with braces. The overlay
[36:57.20]modifier will put a view in front of our
[36:59.68]hero image. Inside the overlay braces,
[37:03.04]type linear gradient.
[37:07.44]Select the one with stops, start point,
[37:09.44]and end point. We'll space this out a
[37:12.16]bit as it can get confusing. Right
[37:15.20]before the S and stops, press enter.
[37:18.88]Press enter again before the S and start
[37:21.28]point.
[37:23.52]Finally, enter before the E and end
[37:26.07]point.
[37:28.40]Double click on gradients stop.
[37:31.44]Left arrow key once.
[37:33.76]Add an open parenthesis.
[37:36.80]Enter on the suggestion color location.
[37:40.16]For color, usecle
[37:42.64]tab
[37:44.16]0.8 for location. The editor is
[37:47.28]recommending adding another gradient.
[37:49.11]Stop, which is what we need. Press tab
[37:52.16]to complete.
[37:53.92]The second color should be dot gradient.
[37:57.76]Location should be one. Press enter
[38:00.64]before the second G in gradient to space
[38:03.44]it out better.
[38:05.52]for start point top
[38:09.28]tab endpoint will be dotbottom.
[38:12.96]Let's break this code down. Linear
[38:15.35]gradient creates a smooth transition
[38:17.04]between colors along a straight line. In
[38:20.32]this case, it transitions from clear to
[38:23.28]our custom gradient color. Linear
[38:26.00]gradient has three arguments. First is
[38:29.28]an array of gradients stops. This
[38:32.16]defines the colors and their locations.
[38:35.68]Start point and end point define the
[38:38.16]direction of the gradient.
[38:40.24]In this case, it starts at the top and
[38:43.44]ends at the bottom of the async image.
[38:46.48]Picture 0% means the top and 100% the
[38:50.40]bottom. From 0 to 80, the gradient is
[38:54.07]clear or fully transparent.
[38:56.96]From 80 to 100, the gradient transitions
[39:00.48]to our custom gradient color, white or
[39:03.44]black, depending on the mode. We can see
[39:06.32]in our preview, the gradient really
[39:08.24]makes the design pop. I'll switch to
[39:10.72]dark mode.
[39:13.52]It looks just as awesome. This wraps up
[39:16.48]home view, but we have one more task
[39:18.64]left. We need to run this code to test.
[39:22.16]In order to run, home view needs to be
[39:24.24]called from content view. Open content
[39:26.96]view.
[39:29.11]Replace constants home string with home
[39:32.32]view.
[39:36.24]At the top toolbar, drop down your
[39:38.48]target devices.
[39:40.40]I'm going with the iPhone 16.
[39:43.59]Press command R to run.
[39:50.16]If everything works, you should have our
[39:52.48]home view displaying on your emulator.
[39:54.88]We can scroll down to see all of our
[39:57.11]titles. Testing the horizontal list.
[40:00.48]They seem to work. A quick note, our
[40:04.16]play and download buttons work but don't
[40:06.48]click smoothly.
[40:08.72]You have to long click to get the
[40:10.07]animations.
[40:12.56]This is because the buttons are embedded
[40:14.40]in the scroll view. The scroll view
[40:16.96]swipe gesture takes priority over the
[40:19.20]button animations. But don't worry, the
[40:22.16]buttons still work 100% of the time.
[40:25.68]This truly wraps up section one. We
[40:28.64]learned a lot in these nine videos. I
[40:31.52]want to say thanks for supporting this
[40:33.28]course so far. My team and I really
[40:35.83]appreciate it. Go ahead and take a break
[40:38.32]if you need it. You deserve it. Give
[40:41.28]yourself a pat on the back and I'll see
[40:43.44]you in section two.
[40:46.40]At some point in your iOS journey,
[40:48.64]you'll work with APIs or external data
[40:51.04]sets. Most of these rely on JSON objects
[40:54.16]to store and transfer data.
[40:56.64]Understanding how to model these objects
[40:58.40]in your Swifti projects is critical. By
[41:01.68]doing this correctly, you'll be able to
[41:03.76]use and display the data in your apps.
[41:07.44]This video marks the official start of
[41:09.28]section two in our Swift UI beginner
[41:11.35]course. The main goal of this section is
[41:14.40]to fetch and display life data from the
[41:16.64]movie database API.
[41:19.04]We'll complete the first step in this
[41:20.56]video, modeling the JSON objects in our
[41:23.59]project. If you're just joining us, feel
[41:26.88]free to grab the section one code from
[41:28.48]our GitHub. The link will be in the
[41:30.96]comments. I do recommend having some
[41:33.68]experience with Swift UI before starting
[41:35.83]this section. Section one of this free
[41:38.31]course is a great place to start.
[41:41.44]Let's take a look at our API data. This
[41:44.48]set is for training movies. The data
[41:47.44]contains an object as shown by the top
[41:49.83]left curly brace. This object has an end
[41:52.96]called page and an array named results.
[41:56.48]The results array contains the data that
[41:58.24]we're interested in. From here, we can
[42:01.59]pick and choose what is needed for our
[42:03.20]app. For Blossom movie, we need ID,
[42:07.44]title, overview, and poster path. Just a
[42:11.44]heads up, I tried original title at
[42:13.92]first, but got titles in their original
[42:16.07]language. Spanish and Japanese included.
[42:19.44]Now that we know what data is needed,
[42:21.59]it's possible to build a model. I'll
[42:23.83]navigate back to Xcode.
[42:26.31]Command N to create a new file.
[42:29.35]Swift file. Next.
[42:32.64]Title. Create.
[42:36.07]Make some space after import foundation
[42:39.04]strruct
[42:40.72]title with braces.
[42:43.44]Struct is short for structure in Swift
[42:45.68]UI. It's a lightweight and efficient way
[42:48.48]to group related data together.
[42:51.04]Type bar id colon int enter bar v bar
[42:56.56]title colon string enter bar var
[43:01.11]overview
[43:02.96]colon string enter and bar poster path
[43:08.31]colon string.
[43:10.96]We model title based on what we need
[43:13.28]from the results array. Before moving
[43:15.83]on, please make sure your spelling
[43:17.83]matches with mine. Misspelling is one of
[43:20.48]the most common mistakes when working
[43:22.40]with APIs.
[43:24.31]I want to show you one more thing with
[43:25.68]our data. This next set contains trying
[43:28.88]TV. Notice title has been replaced with
[43:31.68]name. ID, overview, and poster path are
[43:34.96]still here, but it's important to see
[43:37.20]the slight difference. Keeping this in
[43:39.76]mind, I'll go back to Xcode. Hit enter
[43:43.04]after title
[43:45.28]bar name colon string. This will allow
[43:49.35]our title strct to also work with the TV
[43:52.07]data.
[43:53.76]However, what happens if our app tries
[43:56.48]to find a title string for TV data? As
[44:00.24]we saw, title is replaced with name in
[44:02.72]that set. The app will unfortunately
[44:05.28]crash because it's expecting a value for
[44:07.68]title. To fix this, we can mark name and
[44:11.11]title optionals by putting a question
[44:13.20]mark at the end.
[44:15.83]This tells our strct that title and name
[44:18.31]may or may not have a value. If they
[44:20.96]don't have a value, instead of crashing,
[44:23.76]the app will assign nil to them.
[44:26.56]Nil means no value in Swift.
[44:29.28]Because this isn't data that we manage,
[44:31.76]it's a good idea to mark all the
[44:33.28]properties as optionals
[44:35.68]just in case.
[44:38.00]The properties we need from the results
[44:39.52]array are modeled well here. Just a few
[44:42.40]more things. After title, type colon
[44:46.40]decodable,
[44:48.48]comma, identifiable.
[44:51.44]This makes the struck conform to the
[44:53.52]decodable and identifiable protocols.
[44:57.04]Decodable allows title to be created
[44:58.96]from an external data source. Swift will
[45:01.83]automatically map the data to the strs
[45:04.07]properties if the names match.
[45:07.11]Identifiable requires this strct to have
[45:09.11]an ID property that uniquely identifies
[45:11.83]each instance. This will be useful when
[45:14.80]we use title in our Swift UI views.
[45:18.64]Our title strct is complete in the API
[45:21.83]data. Title was under an array called
[45:24.16]results. We need to do the same thing
[45:26.56]with our title model. Make some space
[45:29.28]before strruct
[45:31.83]strruct
[45:33.44]api object colon decodable with braces
[45:39.11]bar results colon bracket title
[45:44.40]bracket equals brackets.
[45:48.24]Instead of listing results as an
[45:49.76]optional, we set it as an empty array.
[45:52.96]That way if the database returns null,
[45:55.92]there's already an empty array there.
[45:59.20]I'll bring up the working data one more
[46:00.80]time and put it side by side with our
[46:02.88]model.
[46:04.48]Everything is matching up. We start with
[46:06.80]an array called results. This array
[46:09.20]contains a strct title which has the
[46:11.59]properties we need. Good work on this
[46:14.00]one. This is a really important concept.
[46:17.04]It goes beyond iOS if you ever want to
[46:19.59]get into any other coding space. Great
[46:22.31]job again. I can't wait to see you in
[46:24.48]the next one. With our title model
[46:26.88]completed, we're ready to grab our API
[46:29.52]key. This key allows us to request and
[46:31.83]fetch data from the movie database API,
[46:34.96]after which we'll be able to display the
[46:37.04]data in our app. A quick word of
[46:39.20]caution, safeguarding API keys is a
[46:41.68]broad topic that exceeds the scope of
[46:43.83]this course. While hard- coding keys
[46:46.56]directly into your code isn't
[46:47.92]recommended, we'll take a simple
[46:50.00]approach for this practice app by
[46:52.00]storing them in a JSON file. This method
[46:54.48]does keep the key out of the source
[46:55.83]code, but it's not a production level
[46:58.00]solution. However, it's a good step
[47:00.96]towards better practices. In addition,
[47:04.07]it'll also teach us concepts like the
[47:06.16]singleton design pattern and error
[47:08.31]handling. The first step is to get our
[47:10.31]credentials. Open a new Chrome window.
[47:14.00]Inside the search bar, type the movie
[47:17.59]database.
[47:20.24]The first link will do.
[47:23.44]Click on login.
[47:26.96]Please create an account if you need to.
[47:29.11]I already have mine, so I'll just log
[47:30.64]in.
[47:32.72]Select user profile
[47:35.28]settings
[47:37.92]API.
[47:40.07]This is where your API key will be. If
[47:42.64]you just made an account, you'll need to
[47:44.56]generate a key. It's a pretty
[47:46.64]straightforward process and totally
[47:48.80]free. Once you have your key, keep it
[47:51.76]handy. We'll need it here shortly.
[47:54.80]Navigate back to Xcode.
[47:58.80]Command N for a new file. Scroll all the
[48:01.76]way down. Empty. Next.
[48:06.80]API config.json.
[48:10.40]Create.
[48:13.04]Please make sure the file is inside your
[48:14.72]project directory. This file will hold
[48:17.35]sensitive information like our API keys
[48:20.00]and base URLs. In turn, this sensitive
[48:23.59]information will be out of the app
[48:24.88]source code. Inside the JSON file, start
[48:28.07]with an open curly brace and hit enter.
[48:30.72]This creates an object. Type quotes TMDB
[48:35.20]base URL quotes.
[48:39.52]I'll paste the base URL here. It'll be
[48:42.31]in the comments. Please copy and paste
[48:44.24]it as well. close quotes, comma, enter
[48:48.88]quotes, tmdb
[48:51.20]API key quotes, colon quotes. Paste your
[48:56.31]own API key here as a placeholder. I'll
[48:59.68]type in your key.
[49:02.88]Before we move on, please ensure your
[49:05.11]spelling lines up with mine. Caps as
[49:07.59]well. Our API compact.json file is ready
[49:10.64]to go. It just contains two strings, the
[49:13.68]base URL and our API key. Hit command N.
[49:18.88]Swift file this time. Next,
[49:22.48]API config create.
[49:27.92]API config.sswift will be used for
[49:30.55]reading and accessing the contents of
[49:32.24]the JSON file. This allows us to
[49:34.72]dynamically load sensitive information
[49:36.96]like our API keys into our app at
[49:39.76]runtime. Make some space after import
[49:42.40]foundation strct
[49:45.20]API config colon decodable
[49:50.16]with braces. We have to include
[49:52.72]decodable because API config will be
[49:54.96]created by an external source ourjson
[49:57.68]file. Let tmdb
[50:01.83]URL colon string enter. Let tmdb API key
[50:08.48]colon string.
[50:10.64]These are the variables in our do.json
[50:12.31]file. They have to match exactly. Hit
[50:15.28]enter a couple times. Type static let
[50:19.28]shared colon API config equals braces
[50:24.55]at the end of the braces parenthesis.
[50:27.68]We're using something called a singleton
[50:29.35]pattern here. This is a design pattern
[50:31.44]that ensures only one instance of API
[50:33.44]config is created. We're naming that one
[50:36.00]instance shared. Singletons are good for
[50:38.55]centralized resource management and
[50:40.16]usage. We know our logic goes inside the
[50:42.80]braces. The parenthesis at the end are
[50:45.04]new. They immediately execute the
[50:47.04]closure at runtime. In turn, our
[50:49.76]credentials are available right away.
[50:51.92]Inside the braces, type guard let URL
[50:57.44]equals bundle
[50:59.44]main URL.
[51:01.83]Select four resources with extension
[51:04.72]in four resources quotes API config
[51:08.96]tab quotes JSON
[51:13.11]else braces
[51:15.92]fatal error
[51:19.28]API config.json
[51:22.80]is missing or invalid.
[51:27.04]We're trying to find the API config.json
[51:29.28]file in apps bundle. If the file isn't
[51:32.55]found, the uslocks executes and fatal
[51:35.92]error will crash the app. This ensures
[51:38.24]the app can't proceed without the JSON
[51:40.31]file. Make room after the closing brace.
[51:43.92]Now that we found our file, we can get
[51:46.00]the data out of it. Type do with braces.
[51:49.52]After the closing brace, type catch with
[51:51.28]braces.
[51:52.96]The do catch block is used to execute
[51:55.04]code that might throw an error. This
[51:57.35]allows us to handle that error
[51:58.55]gracefully if thrown.
[52:00.96]Inside the do block let data equals try
[52:05.44]data contents of URL
[52:08.31]return try JSON decode API config self
[52:12.80]from data
[52:14.80]inside catch
[52:17.04]fatal error
[52:20.72]failed to load or decode
[52:25.11]API
[52:26.64]config.json JSON
[52:29.59]back slash error autocomplete was pretty
[52:32.64]good here. Let's break this code down.
[52:36.64]Load the contents of the API comp.json
[52:39.35]file from the URL we made above. Try as
[52:42.24]needed here because data contents of can
[52:45.11]throw an error. After that, try a decode
[52:48.40]and return the data as an API config.
[52:51.83]This is done using a JSON decoder. The
[52:54.55]catch block only runs if an error occurs
[52:56.55]in the do block. Again, fatal error is
[52:59.59]used because that app can't run without
[53:01.68]this information. To finish up, we need
[53:04.88]to run the app to make sure this works.
[53:07.28]Navigate to content view.
[53:10.88]Double click on the tab view starting
[53:12.40]brace.
[53:14.31]Click on the closing brace. Enter
[53:18.00]onappear with braces.
[53:21.35]print API config.shared
[53:25.28]tmdb URL below that print
[53:30.48]API config.shared
[53:33.35]tmdb api key. Go ahead and run this code
[53:36.64]with command r.
[53:42.80]If everything works, you should have the
[53:44.96]base URL and API key showing in your
[53:46.88]log. If your app crashed, please double
[53:50.00]check all the files we created.
[53:52.00]Misspelling and capitalization are the
[53:54.31]common mistakes.
[53:56.07]Right now, the app crashes if there's an
[53:58.64]issue with the.json file. In the next
[54:01.35]video, we'll explore a more userfriendly
[54:03.59]way to handle this error. Thank you for
[54:05.92]spending time with us today. We truly
[54:08.16]appreciate your support. Can't wait to
[54:10.24]see you in the next one. Handling errors
[54:12.64]is a key part of your iOS development
[54:14.55]journey. Whether you're connecting to a
[54:16.55]backend or loading a JSON file, errors
[54:19.52]will definitely pop up. In this video,
[54:22.40]we'll refactor our code to gracefully
[54:24.07]handle errors. Currently, our file uses
[54:27.28]fatal error. This was good to help us
[54:29.76]understand how to load our API
[54:31.11]credentials, but it's not a long-term
[54:33.20]solution. Let's dive in and learn how to
[54:36.31]handle errors better. We'll start by
[54:38.72]creating a new file to keep all our
[54:40.40]errors organized. Hit command N on your
[54:42.72]keyboard. Swift file. Next. Errors.
[54:48.40]Create.
[54:50.96]Make some space after import foundation.
[54:53.76]Enum API config error colon error,
[55:00.96]localized error with braces.
[55:04.40]This is the first time we've seen an
[55:05.83]enum. Enums are used for grouping
[55:08.07]related values together in a way that's
[55:10.24]easy to manage and use. Think of them
[55:12.88]like a list of options or categories you
[55:15.20]can choose from. In this enum, we'll
[55:18.16]list all the possible errors related to
[55:19.92]our API config.
[55:22.07]We've also made our enum conform to the
[55:24.07]error and localized error protocols.
[55:27.11]Error allows the enum to be used for
[55:28.72]throwing errors in functions. Localized
[55:31.35]error enables us to provide more
[55:32.80]user-friendly messages or logs. This
[55:35.83]makes it easier to debug issues. These
[55:38.72]two protocols have part enum handle and
[55:41.20]describe errors in a clean way. Inside
[55:44.07]the braces type case file not found
[55:47.68]enter case data loading failed
[55:52.40]parentheses under lying error colon
[55:58.31]error right arrow key enter case
[56:02.72]decoding failed underlaying error error.
[56:08.48]These are the three issues that can
[56:09.83]cause errors in our API config file. the
[56:13.20]file isn't found, the data doesn't load,
[56:16.40]or there is a decoding issue,
[56:19.20]the data loading failed, and decoding
[56:21.59]failed cases both include an underlying
[56:24.55]error. This is because these errors can
[56:27.04]occur for multiple reasons. For example,
[56:30.24]data loading failed might happen because
[56:32.31]the file is corrupted or maybe the app
[56:34.79]doesn't have the right permissions to
[56:36.00]read the file. By including the
[56:38.40]underlying error, we capture the exact
[56:40.79]system error and use it for debugging.
[56:44.31]To finish the file, we can include
[56:46.64]user-friendly error descriptions. Hit
[56:49.20]enter a couple times after the last case
[56:52.07]bar. Error description. Hit tap to
[56:55.11]autocomplete.
[56:57.11]If we pause for a second, the editor
[56:59.59]will recommend finishing the property
[57:01.20]for us. Hit tap to autocomplete again.
[57:05.35]The editor did a pretty good job
[57:06.79]completing this property. Please make
[57:08.96]sure your file looks like mine.
[57:11.92]The error description string gives a
[57:14.16]better error description for each of our
[57:15.92]cases. When we get a data loading failed
[57:19.35]or decoding field case, we include the
[57:22.16]errors localized description to see what
[57:24.40]went wrong. A quick note, the error
[57:27.59]description string is an optional
[57:29.52]because it conforms to the localized
[57:31.28]error, which is also an optional. Our
[57:34.64]API config error enum is complete and
[57:37.20]now it's time to put it to work.
[57:39.28]Navigate back to API config.sswift.
[57:42.72]To start, let's organize the loading and
[57:45.28]decoding logic by placing it in its own
[57:47.83]function. After the parenthesis, make
[57:50.96]some space.
[57:52.79]Private
[57:54.31]static funk load config
[57:59.68]parenthesis throws
[58:02.88]return arrow API config with braces.
[58:07.20]A quick recap on functions. The private
[58:09.92]keyword restricts this functions access
[58:12.00]to only within the API config file. This
[58:15.04]ensures the logic for loading can't be
[58:16.64]called directly from outside. Our
[58:19.11]singleton shared is static which means
[58:21.20]it could be called anywhere in the
[58:22.55]project. Therefore, the function must
[58:25.20]also be static since it'll be going
[58:27.11]inside the singleton. Load config is the
[58:29.92]name of the function. Throws allows a
[58:32.55]function to throw errors if something
[58:34.00]goes wrong, such as a missing file.
[58:36.96]Finally, the return arrow indicates the
[58:39.35]function returns an instance of API
[58:41.28]config once everything is loaded and
[58:43.76]decoded correctly. Next, let's move the
[58:46.48]loading and decoling logic into our
[58:48.07]function. Start from the last catch
[58:50.48]brace and highlight everything up until
[58:52.40]the guard statement. Command X to cut.
[58:56.16]Click inside our function and press
[58:58.07]command V to paste.
[59:00.48]Replace the first fatal error with throw
[59:06.24]API config error file not found.
[59:11.20]In the catch statement, add let error as
[59:16.24]decoding error.
[59:19.76]Replace the second fatal error with
[59:23.11]throw
[59:25.04]API config error dot decoding failed
[59:29.20]underlying error error.
[59:33.20]We specify the error as decoding error
[59:35.83]to know exactly what went wrong with the
[59:37.44]decoding process. Decoding errors are
[59:40.00]really specific and this helps us better
[59:42.24]debug if needed.
[59:44.31]Add another catch statement with braces.
[59:49.20]Inside type throw API config error dot
[59:55.11]data loading failed underlying error
[59:58.07]error.
[60:00.31]With this we successfully integrate our
[60:02.79]enum to handle potential issues
[60:04.55]gracefully. Instead of crashing the app
[60:06.96]with fatal errors, we now catch and
[60:09.59]safely return descriptive errors.
[60:12.55]To finish this file, update our share
[60:14.96]singleton to be an optional.
[60:18.72]Inside the braces, write a do catch
[60:22.24]block.
[60:25.92]Inside do, return
[60:29.28]try load config. Try is needed because
[60:33.11]load config can throw errors.
[60:36.07]In the catch block,
[60:38.64]print
[60:41.83]failed to load API config error.localize
[60:47.35]description.
[60:49.44]After the message, return nil.
[60:54.00]This is why we made our share singleton
[60:55.92]optional. If there's an error during
[60:58.24]setup, share will be nil, allowing the
[61:01.11]app to handle the situation without
[61:03.20]crashing.
[61:04.79]All that's left is to test. Go to our
[61:07.68]content view.
[61:10.64]Delete the old print statements.
[61:16.00]Type if config equals API config.shared
[61:21.83]with braces.
[61:23.76]Print
[61:25.35]config.
[61:27.04]API key. Print
[61:30.88]config.
[61:32.55]base URL
[61:35.11]because API config.shared is an optional
[61:38.31]we have to unwrap it to use it.
[61:40.72]Unwrapping means we check if it's empty
[61:43.92]or nil. The if let statement checks if
[61:47.20]it's nil and if it isn't we print the
[61:50.00]properties. Command R to run.
[61:59.04]If you're showing your API key with the
[62:00.72]base URL, everything went fine. But very
[62:03.76]quickly, let's simulate an error. Go to
[62:07.11]API config
[62:09.28]and in the width extension argument, add
[62:12.07]an extra N.
[62:14.79]Command R again to run.
[62:20.64]This time we're showing the error we
[62:22.64]defined. The APA config file can't be
[62:25.76]found because the extension is mistyped.
[62:28.64]Most importantly, our app didn't crash.
[62:31.59]Very good. Please delete the extra N so
[62:34.72]everything works as expected.
[62:37.20]That's it for this video. Thank you all
[62:39.52]so much. Can't wait to see you in the
[62:41.76]next one.
[62:43.83]In the last lesson, we focused on
[62:46.00]handling errors gracefully to make our
[62:48.00]app more reliable. With that foundation
[62:50.64]in place, the next step is to start
[62:52.88]building functions that will decode our
[62:54.96]server data.
[62:56.72]To begin, head over to content view and
[62:59.76]delete the onappear block.
[63:03.83]This was a placeholder for testing and
[63:06.07]no longer needed. Next, navigate to our
[63:09.59]errors file.
[63:13.20]Here, we'll create a new enum to manage
[63:15.92]and categorize any network related
[63:18.00]errors. Make some space after the
[63:20.48]closing brace. enum network error colon
[63:26.40]error comma localized error brace inside
[63:29.76]the braces case bad URL response
[63:34.07]parenthesis underlaying
[63:37.20]error colon error enter
[63:42.24]case missing config enter twice
[63:47.28]bar error description if your suggestion
[63:50.96]from the editor matches is mine. Press
[63:53.03]tab to autocomplete.
[63:55.35]Once again, the editors autocomplete
[63:57.59]gives us the correct structure. Press
[63:59.68]tab to save some time.
[64:03.35]This is similar to our API config error
[64:05.76]above. The case bad URL response will
[64:08.48]trigger if the application encounters an
[64:10.16]issue with the server response. Some
[64:12.40]examples include a wrong website
[64:14.00]address, a server error, or a response
[64:16.88]that doesn't match the expected format.
[64:19.35]case missing config triggers if
[64:21.28]something goes wrong with the
[64:22.24]configuration of our API config file.
[64:25.35]We'll need this when we unwrap our API
[64:27.35]key and base URL. By handling these
[64:30.55]scenarios, we ensure our app can
[64:32.55]gracefully manage unexpected issues
[64:34.79]during network request.
[64:37.44]With our enum ready, we can make a new
[64:40.00]file to hold our network functions.
[64:42.40]Press command N. Swift file. Next. Data
[64:48.16]fetcher.
[64:49.76]Create.
[64:52.40]Our file is ready. Hit enter once after
[64:55.20]import foundation.
[64:57.11]Let tmdb base URL equals API
[65:01.52]config.shared.
[65:03.59]TMDB base URL. Enter. Let TMDB API key
[65:10.24]equals API config.shared.
[65:13.44]TMDB API key. We define the variables
[65:17.20]globally so that all of our functions
[65:19.35]can access them. Since the singleton API
[65:22.64]configurer is optional, these variables
[65:25.28]are optionals as well. This ensures that
[65:28.00]if there's an issue decoding the API
[65:29.76]config file, our app won't crash but
[65:32.79]handle the missing configurations.
[65:35.59]Hit enter a couple times after API key.
[65:38.96]Bunk fetch titles parenthesis 4 media
[65:45.28]colon string close parenthesis
[65:49.03]async throws
[65:51.92]return arrow
[65:54.40]bracket title bracket braces.
[65:59.03]Let's break down this function. We know
[66:01.52]that fetch titles is the name. It takes
[66:04.64]one parameter a string called media. The
[66:08.16]four in front of media is called an
[66:09.76]argument label. Argument labels make the
[66:12.55]function call more descriptive and
[66:14.40]easier to understand. We used four here,
[66:17.83]but you can use any word that fits your
[66:19.59]use case. Async throws means this
[66:22.55]function will run on a different thread
[66:24.16]than the main thread and might throw an
[66:26.48]error. This is important because as a
[66:29.11]network call, we don't want it running
[66:31.20]on the main thread with the UI. Doing so
[66:34.00]can lead to performance drops and a less
[66:36.24]responsive app.
[66:38.00]Finally, the return arrow indicates that
[66:40.55]this function will return an array of
[66:42.64]our title model. The purpose of this
[66:45.35]function is to connect to the URL and
[66:47.92]attempt to fetch the titles inside.
[66:50.96]The first step in this function is to
[66:52.72]build the URL where our data is located.
[66:55.83]To give you a better idea, I'll paste an
[66:58.31]example of what the URL should look like
[67:00.24]for trending movies.
[67:03.03]It starts with our base URL followed by
[67:05.68]several directories and ends with a
[67:08.00]query that includes your API key.
[67:11.52]To continue, we need to unwrap our TMDB
[67:14.72]base URL and TMDB API key inside the
[67:19.03]function guard. Let base URL equals TMDB
[67:25.83]base URL else with braces inside the
[67:29.59]braces throw network error dot missing
[67:33.92]config.
[67:35.68]below that guard let API key equals TMDB
[67:41.83]API key else with braces same thing
[67:46.55]throw network error dom missing config
[67:51.20]these checks ensure that TMDB base URL
[67:54.16]and TMDB API key are not nil if they're
[67:57.68]available they'll be assigned a base URL
[68:00.40]and API key respectively
[68:02.96]however if either of them are nil
[68:05.68]the function will stop and throw the
[68:07.76]network error.m missing config case.
[68:10.55]This will signal an issue with the
[68:12.07]configuration.
[68:13.68]With our base URL and API key values
[68:15.92]unwrapped, we can build the URL. Make
[68:18.79]some space. Let fetch titles URL equals
[68:24.40]URL parenthesy string colon base URL
[68:30.71]question mark enter dot appending
[68:35.35]parenthesis path
[68:38.23]quotes 3 slash trending
[68:42.88]backslash
[68:44.96]parenthesis media
[68:47.75]parenthesis
[68:49.27]slash slash day
[68:51.92]enter dot appending
[68:56.00]parenthesis
[68:58.23]query items
[69:00.15]bracket enter URL query item name
[69:06.48]parenthesy API key tab API key
[69:15.12]this builds the exact URL we have at the
[69:17.12]top it adds a path including the media
[69:20.23]string and the parameters. Then it
[69:22.96]appends the query items including our
[69:25.12]API key as an argument. Query items are
[69:27.92]pairs of information added to the URL to
[69:30.79]send data to the server. Quick note, we
[69:33.83]use a question mark after the URL
[69:36.15]because the URL string initializer
[69:38.48]returns an optional. This means that the
[69:41.27]string is invalid. The code will safely
[69:43.67]return nil instead of crashing.
[69:46.96]At this point, our URL is complete and
[69:49.75]ready to use. You've done an excellent
[69:52.15]job laying the groundwork for fetching
[69:53.75]data. In the next video, we'll build on
[69:56.88]this and complete the function. As
[69:59.52]always, great work. In the last lesson,
[70:03.60]we started building our fetch titles
[70:05.44]function and created the URL containing
[70:07.84]training movies. In this lesson, we'll
[70:10.96]complete the function by handling the
[70:12.40]API response and parsing the JSON data.
[70:16.32]First, let's fix a sneaky mistake in our
[70:18.71]URL. We forgot a forward slash after
[70:21.92]trending.
[70:24.23]Without the slash, trending movie would
[70:27.04]be combined and the URL won't work. To
[70:30.23]help us debug when we run the code, add
[70:33.84]print fetch titles URL.
[70:37.67]This will print the URL in our console
[70:39.92]and allow us to inspect it. We do get a
[70:42.96]warning because fetch title URL is an
[70:45.44]optional to safely unwrap it and handle
[70:49.04]potential failures. We need to update
[70:51.44]our network errors enum. Open the errors
[70:54.48]file
[70:56.88]inside network error under missing
[70:59.60]config case URL build failed.
[71:05.67]After adding your up build failed, we'll
[71:08.15]see an error because any switch
[71:09.60]statement handling network error now
[71:11.76]requires this new case. Click on the
[71:14.64]error fix.
[71:17.44]The code for our URL build failed can
[71:20.64]simply return failed to build URL.
[71:26.56]With our new case added, we can go back
[71:28.96]to data fetcher.
[71:31.92]Add guard in front of lat
[71:35.28]to safely unwrap our URL.
[71:38.48]At the end of the parenthesis,
[71:40.80]else with braces
[71:43.60]inside the braces, type throw network
[71:46.88]error dot URL build failed.
[71:51.60]This ensures that if our optional URL is
[71:53.67]nil, we throw a new case, preventing
[71:56.80]potential issues down the line. We can
[71:59.60]finally start parsing this response.
[72:02.15]Make some space after our print
[72:03.60]statement.
[72:05.36]Let parenthesy data comma URL response
[72:09.76]parenthesis equals try awaits URL
[72:14.23]session.shared
[72:16.80]data from batch titles URL. Let's break
[72:21.04]this code down. This function returns
[72:23.60]two values. Data, which is the actual
[72:26.64]raw JSON data from the API, and URL
[72:30.08]response, a URL response object that
[72:33.44]contains metadata about the request.
[72:36.56]This could include an HTTP status code
[72:39.76]which tells us whether the request was
[72:41.44]successful or not. These values are
[72:44.40]assigned to the variable stata and your
[72:46.88]our response respectively. Try is needed
[72:50.88]because this function can throw an
[72:52.40]error. For example, if the network is
[72:54.88]down, await means this is an
[72:56.96]asynchronous operation. So the function
[72:59.52]completes in a separate thread without
[73:01.52]blocking the app. URL session is a
[73:04.71]built-in class in Swift that handles
[73:06.96]network request. Dot shared is a
[73:10.08]singleton instance of URL session,
[73:13.52]meaning we don't have to create a new
[73:15.04]session manually. Finally, data from
[73:19.12]fetch titles URL makes a network request
[73:22.15]to the URL we built earlier. It
[73:24.80]downloads the data from the API and also
[73:27.44]gets a response from the server. Next,
[73:30.88]we need to check if the URL response is
[73:33.19]valid. I'll scroll down and hit enter a
[73:36.40]couple times. Guard let response equals
[73:41.12]URL response as question mark http URL
[73:45.12]response comma response status code
[73:49.28]double equals 200 else braces. We first
[73:53.76]check if the URL response above is a
[73:56.15]valid HTTP response. If it is, the HTTP
[74:00.48]URL response is assigned to response.
[74:03.76]Then we check whether our response
[74:05.28]variable has a status code of 200. A 200
[74:08.88]status code means that everything went
[74:10.96]well and the request was successful. If
[74:13.92]either of these checks fail, we can
[74:16.15]throw network error bad our response
[74:20.71]underlying error any error. Since we
[74:23.67]don't have an existing error to pass, we
[74:25.84]need to create our own using NS error.
[74:29.44]NS error stands for nextstep error. an
[74:32.08]Objective C class used to represent
[74:34.15]errors in Apple's framework. Select the
[74:36.80]NS error that includes domain code and
[74:39.76]user info. We can put domain
[74:43.76]code
[74:45.36]and user info
[74:47.67]on their own line to avoid clutter.
[74:51.36]Domain represents where the error is
[74:52.96]coming from. In this case, parenthesis
[74:56.71]data fetcher
[74:59.04]works because the error comes from this
[75:01.19]function. Code is a status code from the
[75:03.84]URL response. We can attempt to get this
[75:06.96]code using parenthesis URL response
[75:11.52]as question mark http URL response
[75:15.67]parenthesis
[75:17.36]status code question mark question mark
[75:20.56]negative one. If a status code exists,
[75:23.92]we use it. If there is no status code
[75:26.64]found, we default it to negative one,
[75:29.76]indicating an unknown issue.
[75:32.48]User info is a dictionary containing
[75:34.40]additional error details such as a
[75:36.64]descriptive error message. We can use
[75:40.08]brackets ns localized description key
[75:44.48]colon quotes invalid HTTP
[75:49.12]response.
[75:50.96]This ensures that if the response is
[75:52.71]invalid, we throw a readable error that
[75:55.52]helps identify the issue. I'll scroll
[75:58.15]down for more room. We check to make
[76:00.64]sure the response was valid. Now we can
[76:02.88]define our decoder. Click outside the
[76:05.19]guard statement. Let decoder equals JSON
[76:10.23]decoder.
[76:11.92]A quick note, our variable poster path
[76:15.19]follows camel case, meaning the second
[76:17.52]word starts with a capital letter. In
[76:19.84]the API, they use snake case, meaning
[76:22.71]words are separated by an underscore
[76:24.71]like poster path. To account for this
[76:28.15]difference, we can add decoder
[76:32.15]key decoding strategy equals convert
[76:35.36]from snake case. This tells the decoder
[76:38.08]to automatically convert snake case keys
[76:40.23]from the API to camelc case. Finally, we
[76:44.56]can complete the parsing. Type return
[76:47.92]try decoder decode API object self tab
[76:55.76]from data parenthesis results escape.
[77:01.67]Since decoding can fail, we need to use
[77:04.23]try in case an error is thrown. The
[77:06.71]decode function takes an object type and
[77:09.36]tries to convert the raw URL data into
[77:11.84]that object. In this case, we're
[77:14.71]decoding the data as our API object
[77:16.80]strct. Remember that API object contains
[77:20.48]an array called results. This results
[77:23.12]array is made up of multiple tile strrus
[77:25.44]where each str represents an individual
[77:27.36]movie or show with its properties. By
[77:30.56]returning results, we get a fully
[77:32.71]decoded array of titles that we can now
[77:35.36]use in our app. I know this was a lot to
[77:38.00]take in and some parts might have been a
[77:40.08]bit confusing. Feel free to rewind and
[77:43.19]revisit any explanation if you need to.
[77:45.76]Also, if you have any questions, don't
[77:48.56]hesitate to ask. I'll do my best to
[77:51.04]help. You're doing an amazing job, and
[77:53.84]the fact that you made it this far
[77:55.52]speaks volume about your dedication.
[77:57.92]That's it for this lesson. Thank you so
[78:00.32]much. I can't wait to see you in the
[78:02.32]next one.
[78:04.32]View models are a key concept not just
[78:06.71]in Swift UI but across many frameworks.
[78:10.32]Their job is to handle data while the UI
[78:12.88]focuses on managing the interface.
[78:15.44]Separating these responsibilities is a
[78:17.60]common practice and an essential skill
[78:19.76]for any developer. In this video, we'll
[78:23.12]demonstrate how to build a view model.
[78:25.52]The first step, of course, is to create
[78:27.12]a new file. Make sure to select the
[78:29.36]Blossom movie folder. Press command N.
[78:33.19]Swift file. Next. View model. Create.
[78:39.52]Hit enter for space.
[78:42.48]It's important that our view model
[78:44.00]instantly updates the UI whenever the
[78:46.32]data changes. Therefore, we need to
[78:49.52]include the at observable macro.
[78:52.56]At observable allows this view model to
[78:55.12]automatically notify the UI of any data
[78:57.67]changes. We typically can't use a struck
[79:00.71]with at observable because strrus are
[79:02.96]value types. This means a new copy is
[79:05.84]created whenever they change. Instead,
[79:08.96]we can define our view model as a class.
[79:13.52]Now we can share and modify data without
[79:16.40]creating new copies. Inside our view
[79:19.12]model class, we'll define an enum to
[79:22.15]represent the different stages of the
[79:23.76]fetching process. Enum fetch status with
[79:28.64]braces case not started
[79:32.80]case fetching
[79:35.28]case success
[79:38.32]case failed parenthesis underlaying
[79:41.28]error
[79:43.44]colon error.
[79:46.00]Before making a request, we start with
[79:48.48]case not started where the UI remains
[79:50.96]empty. Once fetching begins, the state
[79:54.88]switches to fetching displaying a
[79:57.19]progress view. If fetching succeeds, we
[80:01.04]show the normal UI. However, if an error
[80:04.80]occurs, we'll display a view with the
[80:07.92]error message.
[80:09.84]With our enum created, we can now use it
[80:12.48]in the view model. down arrow after the
[80:15.12]enum closing brace and hit enter.
[80:18.48]Private parenthesy set parenthesy bar
[80:22.71]home status colon fetch status equals
[80:26.56]dotn not started
[80:28.88]private set ensures that only the view
[80:31.44]model can update home status. Other
[80:34.23]parts of the app can only read its
[80:35.84]value.
[80:37.36]This is important because only view
[80:39.12]model will know the value for home
[80:41.04]status based on the response.
[80:44.15]We initialize it with dot not started
[80:46.64]because no request has been made yet.
[80:49.19]The next step is to define our data
[80:51.19]fetcher. Before that we need to navigate
[80:54.64]back to the data fetcher file and
[80:56.88]convert it into a strruct.
[80:59.76]At the top after import foundation hit
[81:02.71]enter
[81:04.32]strct
[81:06.56]data fetcher open brace. Scroll to the
[81:10.80]bottom
[81:12.32]and add a closing curly brace to
[81:14.56]complete the strct.
[81:17.76]This was something I forgot to do in the
[81:19.76]earlier video and I apologize for that.
[81:23.19]The good news, you get to see how we fix
[81:26.00]mistakes in real time.
[81:28.96]With data fetcher fixed, we can return
[81:31.52]to our view model file.
[81:34.15]Press enter for a new line.
[81:36.80]private
[81:38.64]let data fetcher equals data fetcher. A
[81:43.76]quick note, private isn't required here,
[81:46.80]but since no other file needs access to
[81:48.71]data fetcher, it's good practice to
[81:50.96]include it. That way, when we call
[81:53.92]strrus and other files, we're only
[81:56.23]presented with relevant options.
[81:59.19]Next, we'll create an array to store
[82:02.15]training movie titles. New line bar
[82:06.32]trending movies
[82:08.96]colon bracket title bracket equals
[82:15.04]brackets.
[82:16.71]The trending movies array will hold a
[82:19.04]list of title strrus. We initialize it
[82:21.92]as empty to ensure our app doesn't break
[82:24.71]if no data is returned. With the
[82:27.12]property set for now, we can move on to
[82:29.67]creating our functions. Make some space
[82:32.15]and add funk. get titles parenthesis
[82:36.15]async with braces.
[82:38.96]Async is used because this function will
[82:41.19]make a network call. This allows it to
[82:43.67]run on a separate thread, preventing it
[82:45.76]from blocking the main UI. At the start
[82:48.08]of the get titles function, we could
[82:50.32]type home status equals fetching.
[82:54.15]When this function is first called, it
[82:56.48]will allow us to display a progress view
[82:58.56]to show loading.
[83:00.71]Next, we can add a do catch block
[83:05.76]since the function we're about to call
[83:07.28]can throw errors. Inside do trending
[83:10.80]movies equals try awaits
[83:14.48]data fetcher.betch titles for movie.
[83:21.67]Remember data fetcher.betch titles
[83:24.56]returns an array of decoded title
[83:26.23]strrus. We pass a string argument movie
[83:29.52]to build a URL for training movies. This
[83:32.40]is useful because in the future we'll
[83:34.96]need to fetch training TV shows the same
[83:36.71]way. If this completed successfully, we
[83:40.23]can say home status equals success.
[83:45.19]This tells our UI to show the home view.
[83:48.56]We just need to handle any errors. I'll
[83:51.36]scroll down first
[83:53.44]and add print error.
[83:57.52]This prints the error to log for
[83:59.36]debugging.
[84:01.52]Now we set home status to failed
[84:06.63]passing error as underlying error.
[84:10.23]This gives us an error message that we
[84:12.40]can have the UI show. This is a simple
[84:15.28]view model but we covered the core
[84:17.44]concepts of how it works. We just have a
[84:20.48]few more steps before we can see it in
[84:22.80]action but we're almost there. Thank you
[84:26.08]very much for spending some time with me
[84:27.60]today. I can't wait to see you in the
[84:29.67]next one.
[84:32.23]In parameters are useful when you need
[84:34.63]to modify a value inside a function and
[84:37.04]have that change persist. Normally
[84:39.84]function parameters in Swift are
[84:41.28]constants, meaning they can't be
[84:43.19]changed. With an out, you can pass a
[84:46.32]variable into a function and have it
[84:48.40]change directly. In this video, we're
[84:51.52]going to apply this concept to complete
[84:53.76]our view model.
[84:55.84]inside our view model. Right now, we're
[84:58.40]successfully getting the training
[84:59.76]movies. However, each image from the API
[85:03.19]is only half complete. Let's jump into
[85:05.67]the constants file to see what's going
[85:07.92]on. The API only returns the last part
[85:11.28]of the image URL.
[85:14.48]To display the full image, we need to
[85:17.04]add the URL beginning part ourselves.
[85:20.08]We're going to create this in function
[85:22.56]inside our constants file.
[85:24.80]Let's first define the poster path
[85:26.56]beginning. I'll scroll down.
[85:29.92]I'll also make some room after test
[85:31.60]title URL 3.
[85:34.08]Type static
[85:36.15]let poster URL start
[85:41.19]equals tab.
[85:44.23]The editor might recommend it for you,
[85:46.23]but if not, you can just copy and paste
[85:48.56]it from above.
[85:50.40]We can delete the ending forward slash.
[85:52.80]It's already included in the API
[85:54.56]response.
[85:56.23]Right arrow, hit enter a couple times
[85:58.88]for space. Now we can define the
[86:01.36]function static funk add posture path
[86:06.88]parenthesis 2 titles
[86:10.08]colon and out
[86:12.96]bracket title bracket parenthesy with
[86:17.44]braces.
[86:20.00]This function is static because we need
[86:22.40]another part of the app to access it.
[86:24.96]The function name is add poster path. We
[86:27.84]use the argument label two making it
[86:30.56]clear that we are adding the poster path
[86:32.32]to the titles. The titles parameter is
[86:35.19]an array of our title strct. The nl
[86:38.08]keyword signals that this array goes
[86:39.67]into the function gets modified and
[86:42.96]comes back out with the changes applied.
[86:45.92]I'll scroll down a bit more. Inside the
[86:48.56]add poster path function, type four
[86:50.96]index in titles indices with braces.
[86:56.48]This loops through all the titles in the
[86:58.15]array and gives us the index of each
[87:00.56]one, allowing us to modify them
[87:02.48]directly.
[87:04.15]Inside the for loop, add if flat path
[87:07.36]equals titles bracket index.polster path
[87:10.80]with braces.
[87:12.80]This checks if poster path is nil. If it
[87:15.84]has a value, we assign it to the
[87:18.00]variable path and modify it inside the
[87:20.00]braces. Otherwise, we just leave it nil.
[87:23.76]We can finally complete the
[87:25.04]modification.
[87:26.63]Inside the ifat statement, enter titles
[87:30.15]bracket index.poster
[87:32.96]path equals constants.poster
[87:36.88]URL start plus path.
[87:40.15]This takes the existing poster path,
[87:42.56]combines it with the base URL, and
[87:45.04]updates this value for each title in the
[87:47.12]array. Our function is complete. Let's
[87:50.32]use it in our data fetcher file.
[87:53.28]Scroll down to our return statement.
[87:56.23]Instead, type var titles equals.
[88:00.88]This stores the titles in an array,
[88:03.28]allowing us to modify it before
[88:04.80]returning the data.
[88:06.96]Now we can apply our in function to
[88:09.60]complete the poster path for each title
[88:11.84]before returning the array. Make a new
[88:14.63]line and add constants
[88:17.44]dot add poster path to titles.
[88:21.28]Return
[88:23.04]titles. The and before titles tell Swift
[88:27.28]modify the actual array, not a copy.
[88:30.71]This allows our function to apply
[88:32.32]changes directly. As we discussed
[88:34.56]earlier, we're complete with the in
[88:37.19]function, but we have time for one more
[88:39.36]thing. Navigate to our title file.
[88:43.44]We're going to create an array of sample
[88:45.28]data. This sample data will help us when
[88:47.92]we go back to the UI and work with our
[88:50.32]previews.
[88:51.84]Make some space after var poster path.
[88:55.04]Type static var preview titles equals
[88:59.92]brackets.
[89:02.00]Inside the brackets, type title
[89:05.19]down arrow to our strct. Right arrow.
[89:08.63]Select the one that has all the
[89:09.84]properties.
[89:14.23]This will ensure our sample data matches
[89:16.08]the actual structure of our API
[89:17.67]response.
[89:19.67]I'm going to space this out by pressing
[89:21.44]answer before title
[89:24.40]and after the closing parenthesy.
[89:27.60]This makes the code easier to read.
[89:30.23]Now copy this line.
[89:33.52]At the end of the line, type comma,
[89:36.00]enter, and command B to paste.
[89:39.76]Do it one more time.
[89:42.40]This gives us three tile strokes to work
[89:44.71]with.
[89:46.48]We just need to fill in our data. It's
[89:48.71]going to be pretty simple. Just follow
[89:50.71]along. Click on the first ID one. Tab.
[89:55.92]Beetlejuice.
[89:58.88]Tab Beetlejuice
[90:02.63]tab a movie about
[90:06.71]Beetlejuice
[90:09.76]tab constants dot test title URL
[90:16.32]I'll do the same for Pulp Fiction start
[90:18.88]at ID two
[90:22.15]P fiction
[90:25.12]P fiction
[90:28.08]a movie
[90:30.56]about old fiction
[90:34.08]constants test title URL 2.
[90:38.15]Finally, we just need the Dark Knight
[90:41.44]three. The Dark Knight.
[90:45.60]The Dark Knight.
[90:49.44]A movie about The Dark Knight.
[90:55.44]Constants test title URL3.
[90:59.44]That wraps up this video. We learned
[91:01.92]about inout functions and even got our
[91:04.23]sample data ready. I know we stepped
[91:06.80]away from Swift UI for a bit, but in the
[91:09.19]next lesson, we're coming back with an
[91:11.19]important topic. the infamous depending
[91:14.48]on who you ask model view view model or
[91:17.67]MVVM pattern. Thanks for spending some
[91:20.56]time with me today.
[91:23.19]The model view view model pattern is a
[91:25.60]popular design choice for many reasons.
[91:28.08]It helps keep your code organized by
[91:30.32]separating UI logic from business logic,
[91:32.96]making it more maintainable and easier
[91:35.12]to test. Like most things in coding,
[91:38.40]it's a bit controversial as some
[91:40.56]developers argue it's unnecessary in
[91:42.40]Swift UI. In my experience, MVVM shines
[91:46.63]in complex projects, helping clean
[91:48.80]uploaded files and making code more
[91:51.12]structured and readable.
[91:53.52]Even though Blossom Movie is small,
[91:55.84]applying MVVM will give us experience so
[91:58.88]you can decide if it's the right pattern
[92:00.71]for your own projects. To recap, our
[92:04.00]model is represented by the title file.
[92:06.71]This file defines the API object and is
[92:09.60]used for decoding our API response.
[92:12.32]There's also sample data to help us with
[92:14.71]our Swift UI views. While we're here, it
[92:18.23]doesn't hurt to fix a typo.
[92:22.63]Moving on, we have the data fetcher
[92:24.96]file.
[92:27.12]This file acts as a service that holds
[92:29.44]our network logic. It contains a batch
[92:32.23]titles function which connects to our
[92:34.56]API,
[92:36.08]retrieves the data and decodes it into a
[92:39.12]title array. Next, we have our view
[92:42.32]model.
[92:44.96]It includes an enum to track the fetch
[92:46.71]status, initializes a data fetcher, and
[92:50.00]stores an array of training movies.
[92:52.32]Inside the get titles function, it calls
[92:54.88]fetch titles to populate the trending
[92:57.12]movies array. Thanks to the at
[92:59.52]observable attribute, the view model
[93:01.76]automatically updates the UI whenever
[93:03.92]the data changes. To complete the MVBM
[93:07.19]pattern in this project, we need to
[93:09.36]connect the view model to our UI. First,
[93:12.56]open the horizontal list view file.
[93:16.15]Right now, it contains a static array of
[93:18.80]poster strings.
[93:20.80]Remove everything to the right of bar
[93:22.63]titles.
[93:26.40]replace it with colon bracket title.
[93:31.92]This allows us to define a title array
[93:33.76]when calling this view making it
[93:35.76]dynamic.
[93:37.44]We get a few errors. The first one being
[93:39.84]because we use self as the ID in our for
[93:42.23]each loop. Our title struck already
[93:44.80]conforms to the identifiable protocol.
[93:47.60]So we can remove ID do self.
[93:52.08]To fix the next error, use the title
[93:54.40]poster path property for the async image
[93:56.80]URL.
[94:02.56]Remember, all the title properties are
[94:04.71]optionals in case they're known in the
[94:06.56]API. Therefore, use a double question
[94:09.76]mark operator to provide an empty string
[94:12.63]if the value is missing. A default URL
[94:15.84]will be a better approach, but an empty
[94:17.84]string works for now. We have one more
[94:20.40]error in this file. The preview requires
[94:23.04]an array of titles to compile. Scroll
[94:26.32]down, click on the error, and select
[94:29.44]fix.
[94:32.32]This adds the titles parameter, which we
[94:35.12]can set to title.review
[94:38.32]titles to resolve the issue. Our sample
[94:42.00]data coming in clutch. We're ready to go
[94:44.80]with this file. There are a few more
[94:47.28]errors to address. But before we fix
[94:49.36]them, open API config.json.
[94:54.56]Replace your key with your actual API
[94:57.19]key from the movie database. I'll be
[94:59.84]doing this off camera, but please make
[95:02.23]sure to do this as the code will work
[95:04.08]without it. If you need help getting
[95:06.63]your key, check out my API keys video
[95:08.96]for guidance. With that done, navigate
[95:12.40]to home view. Under hero test title, add
[95:16.63]let
[95:18.32]view model equals view model.
[95:23.04]This creates a new view model that will
[95:25.04]control the UI. Press enter after the
[95:28.15]scroll view brace.
[95:30.80]Type switch.
[95:33.28]Pause for a second to see if Xcode auto
[95:35.44]completes it. If it does, press tab to
[95:38.88]start the switch statement. Pause. Then
[95:42.15]press tab again to autocomplete the
[95:43.92]rest.
[95:47.28]It's always nice when Xcode helps us
[95:49.19]out. However, my switch statement isn't
[95:52.15]quite right. I need to change the third
[95:54.56]case to success.
[95:58.80]For now, I'll leave an empty text in
[96:01.60]there.
[96:07.28]Next I need to add the last case
[96:11.12]failed
[96:14.48]let error
[96:17.04]inside this case I'll simply add text
[96:21.52]error back slash error
[96:25.04]to break it down we executed a switch
[96:27.76]statement on the view modelhome status
[96:29.84]enum when cases do not started we We
[96:33.60]show an empty view with fetching a
[96:37.28]progress view appears in success. We
[96:41.04]currently have a text placeholder, but
[96:43.44]we'll add our UI here soon. Finally, in
[96:47.19]failed, we display the error as a text
[96:50.00]on screen.
[96:52.15]Let's scroll down to fix the error
[96:53.67]that's showing.
[96:56.96]Click on the error and select fix.
[97:00.88]This adds a missing titles array.
[97:03.60]Inside that type view model trending
[97:07.28]movies
[97:09.36]select the other three horizontal list
[97:10.96]views and comment them out using command
[97:14.00]forward slash.
[97:17.76]We pass the view model training movies
[97:19.67]to our horizontal list view which will
[97:21.76]display them. Although right now the
[97:24.63]training movies are empty. Now scroll up
[97:28.32]and double click on the lazy vstack
[97:30.56]brace.
[97:33.28]Reselect everything from the ending
[97:35.11]brace back to lazy vstack.
[97:39.52]Press command X to cut.
[97:42.32]Inside the success case,
[97:45.19]select the text and paste with command
[97:47.92]V.
[97:51.44]If the case is success, the UI will not
[97:54.32]be displayed.
[97:56.00]The last step is to make sure the view
[97:57.60]model populates a training movies array.
[98:00.08]Double click on scroll view's open
[98:01.76]brace.
[98:04.56]On the closing brace add dot task
[98:08.15]braces. Inside task type await view
[98:13.11]model.get titles.
[98:16.56]The task modifier runs an asynchronous
[98:19.36]task when the view appears allowing
[98:22.23]await view model.get titles to fetch
[98:25.36]data without blocking the UI. This is
[98:28.40]the moment of truth. If your preview
[98:30.96]builds and you can scroll down to see
[98:33.04]the trending movies list, you're good.
[98:36.08]Scroll to the right and take a moment to
[98:38.48]appreciate how fast and smooth it
[98:40.48]scrolls.
[98:42.40]This whole section has been leading up
[98:43.92]to this moment. If you're not so lucky,
[98:47.11]we'll troubleshoot. Now, press command R
[98:49.76]to run the app.
[98:56.00]I got the simulator up and the list is
[98:58.63]working great.
[99:00.88]Open your log and the first thing to
[99:03.52]check is the API address. Copy and paste
[99:06.80]it to an empty browser window.
[99:12.08]You should see data returned just like
[99:14.08]mine.
[99:15.67]If you don't see data, check your API
[99:18.23]address to make sure it wasn't mistyped.
[99:20.96]Also verify that your API key is valid.
[99:24.23]You might also have configuration
[99:25.84]issues. Compare your code to the
[99:28.00]completed version to find any mistakes.
[99:31.11]Misspellings in the title strct or API
[99:33.84]config.json are also common issues. This
[99:37.84]wraps up the video. Great job making it
[99:40.32]this far. We've learned a lot in the
[99:42.56]course so far and even implemented a
[99:44.96]clean MVVM design. I'll end it here, but
[99:48.56]I can't wait to see you in the next one.
[99:51.67]If you're not careful, a function can
[99:54.00]quickly get out of control, especially
[99:56.23]when you start reusing it for different
[99:57.67]tasks. To help combat this, helper
[100:01.11]functions in Swift can keep your code
[100:02.71]clean, organized, and easier to manage.
[100:06.23]We'll cover an example of using a helper
[100:08.08]function in this video to show how it
[100:10.40]can help simplify your code.
[100:12.80]Currently, we're fetching training
[100:14.71]movies from our API using the fetch
[100:16.88]titles function. Since training TV has
[100:19.67]the same URL, the only change needed is
[100:22.40]swapping movie for TV. But we also need
[100:25.36]to fetch top rated movies and TV shows.
[100:28.80]These calls have slightly different
[100:30.15]URLs, meaning modifying our fresh titles
[100:32.63]function.
[100:34.15]Let's open data fetcher and take a look.
[100:37.67]I'll paste the URL for top rated media
[100:40.15]right after the training URL.
[100:43.36]The URLs are similar with the main
[100:45.76]difference being the order of media and
[100:47.52]type. For example, the first URL uses
[100:51.28]trending forward/mov
[100:53.28]while the second uses movie/top rated.
[100:57.28]Additionally, trending includes day
[100:59.92]before the API query whereas the latter
[101:02.63]places top rated before the query.
[101:06.08]Since only the URL changes, we can keep
[101:08.88]the same function, add a parameter, and
[101:12.15]update the logic to build the
[101:13.52]appropriate URL. We could add the logic
[101:16.23]directly inside this function, but it
[101:18.23]will get big fast. Looking ahead, we'll
[101:21.60]also need this function for our search
[101:23.04]screen. Therefore, using a helper
[101:26.15]function now is a better approach.
[101:29.67]First, let's add the new parameter.
[101:32.80]After four media string, put a comma
[101:37.52]add by type colon string.
[101:42.71]This lets us specify the media as either
[101:44.71]movie or TV and choose between trending
[101:48.08]or top rated as a type. Now we can make
[101:51.84]our helper function. Double click on the
[101:54.48]fetch titles closing brace.
[101:58.00]Add a couple lines.
[102:00.71]Type private
[102:03.60]funk build URL
[102:07.67]parenthesis media colon string comma
[102:11.84]type colon string
[102:14.96]parenthesis throws
[102:18.00]return arrow
[102:20.00]URL question mark with braces.
[102:24.08]We mark the function as throws allowing
[102:26.56]us to throw error enums when needed.
[102:29.52]Inside the helper function, we need to
[102:31.92]unwrap base URL and API key. Lucky for
[102:35.60]us, this is complete already. Scroll up.
[102:39.92]Cut the first two lines from fetch
[102:41.52]titles.
[102:44.48]Paste them inside the build URL
[102:46.08]function.
[102:50.96]Make some space and add var path colon
[102:55.19]string.
[102:57.52]This path will be used to construct the
[102:59.28]correct URL based on the type.
[103:02.63]I'll scroll all the way down for more
[103:03.92]room.
[103:05.60]Add a couple lines.
[103:08.00]If type double equals parenthesis
[103:11.60]trending
[103:13.44]parenthesis braces
[103:16.40]path equals parenthesis 3/
[103:21.92]trending
[103:24.00]slash backslash parenthesis media
[103:28.48]parenthesis slashday
[103:33.67]else if
[103:37.11]type double equals top underscore rated
[103:43.52]braces
[103:45.60]path equals parenthesis 3/backslash
[103:52.00]parenthesis media parenthesis
[103:55.60]for slash top_rated
[104:01.84]else parenthesis throw network
[104:08.00]URL build failed.
[104:11.92]With the path correctly made, we just
[104:14.23]need to build the URL. We got lucky
[104:16.88]again and already completed this. Scroll
[104:19.52]up to the fetch titles function and cut
[104:21.76]the guard let statement.
[104:24.71]Paste it under the else statement and
[104:26.32]build URL.
[104:31.19]Let's rename bash headles URL to just
[104:33.60]URL.
[104:36.48]Also replace the hard-coded path and
[104:39.28]appending with our path variable
[104:45.19]below the guardlet statement
[104:48.48]add return URL.
[104:51.92]This completes the build URL function.
[104:55.52]Let's put this new function to work by
[104:57.28]scrolling up one more time. Before the
[105:00.00]print statement, type
[105:02.48]let fetch titles
[105:06.48]URL equals try
[105:09.92]build URL media media type type.
[105:16.08]We just need to unwrap since the build
[105:18.15]URL function returns an optional.
[105:21.04]Guard let fresh titles URL equals fetch
[105:25.19]titles URL else
[105:28.32]braces throw network error dot URL build
[105:33.19]failed.
[105:36.48]I'll fix our spacing.
[105:42.71]That completes our fetch titles
[105:44.32]function, allowing it to fetch both
[105:46.56]trending and toprated titles. Without
[105:49.76]the build your all helper function, this
[105:52.00]logic would stay inside fetch titles,
[105:54.23]making it messy and harder to maintain.
[105:57.28]Please try to use helper functions
[105:58.80]whenever they make sense. To wrap this
[106:01.52]up, go back to view model.
[106:05.11]Add the missing parameters for our fetch
[106:06.88]title call.
[106:11.60]We can put parenthesis trending.
[106:16.80]That's it for this video. Thank you for
[106:19.04]spending some time with me today. I'll
[106:21.11]see you in the next one. When making
[106:23.11]multiple async calls, using try wait for
[106:26.08]each one can slow things down. This is
[106:28.80]because each call must finish before the
[106:31.19]next one starts. To improve speed, we
[106:34.71]can use async let allowing each call to
[106:37.67]run parallel instead.
[106:40.00]In this video, we'll demonstrate how to
[106:42.40]implement async using blast movie as an
[106:45.36]example. Our view model currently only
[106:47.67]fetches training movies. We still need
[106:50.23]to get training TV shows, toprated
[106:52.71]movies, and toprated TV shows. The hard
[106:55.92]part is already done since our fetch
[106:58.00]titles function is set up to handle
[106:59.60]different URLs. Now, we just need to put
[107:02.23]it to work. We can start by defining our
[107:04.63]new arrays. Make a line after training
[107:07.52]movies.
[107:09.60]Type bar trending TV colon bracket title
[107:15.04]equals empty brackets enter bar top
[107:19.28]rated movies colon bracket title equals
[107:22.96]empty brackets enter bar top rated TV
[107:28.80]colon bracket title equals empty
[107:30.63]brackets like the training movies we
[107:33.67]create these list as empty in case the
[107:36.00]API returns them no next scroll Scroll
[107:39.44]down and press enter after the try await
[107:42.00]closing parenthesis.
[107:45.04]We'll call data fetcher to populate our
[107:46.96]new arrays. at trending TV equals try
[107:51.60]await data fetcher fetch titles for TV
[107:57.28]by trending
[108:00.32]top rated movies
[108:04.71]equals try await
[108:08.08]data fetcher fetch titles or movie
[108:12.71]by top_rated
[108:18.88]Top rated TV
[108:21.04]equals tryate
[108:24.23]data fetcher fetch titles or TV by
[108:28.56]top_rated.
[108:31.36]From here we can open home view. Go
[108:34.40]down.
[108:37.28]Uncomment the horizontal list views by
[108:39.28]selecting them and pressing command
[108:41.60]forward slash.
[108:44.23]Errors appear because we need to pass an
[108:46.48]array for the different views.
[108:49.11]Click on the first error and press fix.
[108:54.08]Add view model
[108:57.04]dot trending TV.
[109:00.40]Click on the next error and press fix.
[109:04.80]Add view model
[109:07.36]dot top rated movies.
[109:10.80]We just see the last error.
[109:15.44]view model toprated TV.
[109:19.84]Our preview updates and if we scroll
[109:22.32]down, the rest of our titles appear.
[109:25.36]We've put in some work and our app is
[109:27.67]pretty well organized, making this
[109:29.67]addition seamless. Press command R to
[109:32.48]run the code.
[109:37.92]Scrolling down to the right,
[109:40.96]all the titles load pretty quickly.
[109:43.76]I'm going to close the app a couple of
[109:45.36]times and reopen it to test loading
[109:47.52]speed.
[110:02.48]Not going to lie, it's actually pretty
[110:04.48]fast.
[110:05.67]Keep in mind this is a small app with
[110:07.84]only four network calls going so far. As
[110:10.88]we add more to it, it might slow down
[110:13.19]with our current async setup. Let's see
[110:15.92]if we can improve it by going back to
[110:17.92]view model.
[110:20.00]I'll close the log.
[110:22.48]Right now, we're using try wait for each
[110:25.04]call. This means training movies runs
[110:28.08]first. Training TV waits until it's done
[110:30.80]to start and so on with the other calls.
[110:34.32]To speed things up, we can use async
[110:37.11]let.
[110:38.71]Starting with training movies, highlight
[110:41.11]everything to the left of data fetcher.
[110:44.80]Replace it with async let t movies
[110:50.00]equals.
[110:52.32]We can do the same for training TV.
[110:57.84]Async
[110:59.76]let tv
[111:03.52]equals.
[111:05.67]Moving on to top rated movies
[111:10.00]async.
[111:12.15]Let
[111:14.48]TR movies
[111:18.71]equals.
[111:20.63]And finally
[111:23.76]as sync
[111:25.84]let
[111:27.52]R TV
[111:30.48]equals. Now we can update training
[111:32.96]movies
[111:36.63]to try movies.
[111:39.52]Training TV to try TV. Top rated movies
[111:43.19]to try
[111:45.19]movies. And finally, top rate TV to try
[111:49.19]08 TRTV.
[111:51.92]By using async let the calls run in
[111:54.63]parallel instead of each one waiting for
[111:57.04]the previous one. Press command R to run
[112:00.00]the app.
[112:04.08]We have our app ready. I'll do the same
[112:06.48]test a couple of times. Closing the app
[112:08.80]and reopening it.
[112:25.11]The app is slightly faster, but as
[112:27.44]mentioned, this could really make a
[112:29.11]difference with more network calls and a
[112:31.19]bigger app.
[112:33.04]We'll stop here. Thank you for spending
[112:35.28]time with me today. I can't wait to see
[112:37.44]you in the next one.
[112:39.84]API network requests are one of the most
[112:42.08]performance- taxing and expensive things
[112:44.15]your app can do. It's important to think
[112:46.71]about how often you need to make a
[112:48.63]request and adjust your code
[112:50.48]accordingly. In this video, we'll
[112:53.59]rethink how our app is connecting calls
[112:56.08]and modify to fit the correct profile.
[112:58.96]In our view model class, we have our get
[113:01.52]titles function retrieving our data from
[113:03.52]the API.
[113:05.28]The issue is that the titles are
[113:06.88]retrieved even if the list is already
[113:08.80]populated. This results in more network
[113:11.28]calls than we need since our data
[113:13.19]doesn't update consistently.
[113:15.52]If this was a chatting app, it would
[113:17.67]make sense. Let's run the code to see.
[113:24.71]We can scroll down to see the titles
[113:26.40]populate. If we change the tab to
[113:28.88]upcoming
[113:30.56]and go back to home,
[113:32.96]the view is back to the top. This is
[113:35.76]because the get titles function repul
[113:38.08]the titles. With this API, it's unlikely
[113:41.76]the data changes that fast. When the
[113:44.48]user opens the app, populating the
[113:46.71]titles there is enough. We can fix this
[113:49.67]in our view model class.
[113:52.40]Scroll down
[113:55.19]right after home status equals stop
[113:57.19]fetching. Make a new line.
[114:00.63]If trending movies
[114:04.08]do is empty
[114:06.71]open brace.
[114:08.80]Scroll down to the catch statement.
[114:11.76]Enter.
[114:13.36]Add a closing brace.
[114:16.08]This makes sure the API is called only
[114:18.08]if trending movies are empty.
[114:20.88]Type else with braces after the if
[114:23.36]statement. Home status equals dots
[114:27.04]success. This lets our view model know
[114:29.92]that the list are populated and to set
[114:32.00]the UI normally. Hit command R to run.
[114:40.32]Now scroll down to load the titles.
[114:43.59]Press upcoming and go back to home.
[114:47.59]the titles didn't repopulate, making our
[114:49.84]API calls more efficient. It's a good
[114:52.40]idea to think about the calls you're
[114:54.00]making and how you need them. There's
[114:56.88]one thing left before wrapping up. Go
[114:59.28]back to the view model.
[115:02.08]Make sure you're inside the is empty
[115:03.59]block.
[115:05.19]Change the home status to fetching.
[115:08.56]This will keep the UI loading.
[115:11.11]Run the code.
[115:16.08]The progress view is sitting in the
[115:17.52]corner looking odd. To fix it, open home
[115:20.40]view.
[115:23.44]Select progress view.
[115:26.40]Add the dot frame modifier
[115:30.00]width and height.
[115:32.96]Set the width to go.
[115:35.84]Dow width. Tab. Gio.
[115:42.48]Run.
[115:47.36]Much better. Let's reset our status to
[115:50.15]do success in the view model.
[115:54.32]Run the code one more time.
[115:59.76]This is a big moment. Section two of the
[116:02.40]course is officially completed. We've
[116:04.88]been uploading this section for about 2
[116:06.56]months. I want to thank you all for the
[116:08.96]support. It really means a lot to us.
[116:12.15]Section three will cover navigation.
[116:14.56]Can't wait to see you there.
[116:17.28]Most of the time when you're working
[116:18.48]with navigation, you'll go into some
[116:20.88]kind of detail screen as your second
[116:22.71]view. That usually means showing more
[116:25.36]information about whatever you're
[116:27.19]displaying on the main screen. In our
[116:29.76]case, we've got a list of titles.
[116:32.48]Therefore, we'll navigate to a screen
[116:34.56]that shows more details like the name
[116:36.63]and description. In this video, we're
[116:39.92]going to create this detail screen. Then
[116:42.23]we'll be ready for navigation in the
[116:44.40]next one.
[116:46.08]The first step is to create a new file.
[116:48.71]Hit command N. Swift UI view. Next,
[116:54.40]title detail view. Great.
[117:00.56]Make some space after line 10. We want
[117:03.52]to define a title variable to build our
[117:05.52]view. Let title colon title make more
[117:10.08]space.
[117:14.15]Our preview needs a title argument.
[117:16.48]Click on the error fix.
[117:20.15]We can put in title
[117:23.44]preview titles bracket zero. This takes
[117:27.19]the first title from our preview titles
[117:28.96]array. Our sample data coming in clutch.
[117:32.80]I'll also show the canvas to help us
[117:35.11]build the view.
[117:42.48]Now we can build how the information
[117:44.00]will be displayed. Delete the famous
[117:46.48]hello world
[117:48.88]and set type geometry reader geometry
[117:51.76]in. We're going to display the title
[117:54.48]image for now but move on to YouTube
[117:57.04]video later. Geometry reader allows us
[117:59.59]to get the size of the screen for this
[118:01.67]view.
[118:03.11]Next, type scroll view with braces. Some
[118:06.56]of the titles have pretty long
[118:07.92]descriptions. In case this happens,
[118:10.88]scroll view will allow us to scroll
[118:12.40]down. Moving on, type lazy be stack
[118:18.08]alignment and content
[118:20.56]leading tab. Press enter for braces.
[118:25.67]This lazy vstack aligns its elements to
[118:27.92]the left of the screen and loads them
[118:29.92]when needed. Now we can declare our
[118:32.00]async image. Select the one with URL.
[118:35.36]URL parenthesis string title poster path
[118:40.32]question mark question mark quotes.
[118:43.59]We unwrap the title poster path and give
[118:46.15]an empty string in case it's nil. Add an
[118:48.80]open brace image in press enter a few
[118:51.92]times. after the closing brace
[118:55.36]placeholder
[118:56.96]progress view.
[119:00.32]This adds a nice progress circle as the
[119:02.15]image loads. Inside the async image
[119:04.71]braces, we can add modifiers
[119:06.80]image.resizable.scale
[119:09.92]to fit.
[119:12.80]Finally, add a dot frame modifier after
[119:15.52]the closing placeholder brace
[119:19.04]frame
[119:20.63]width and height geometry sizewidth
[119:25.76]tab geometry size.height
[119:30.08]times 0.85.
[119:34.08]This frame keeps a place for the image
[119:36.32]as it loads.
[119:38.48]With the image ready, we can show some
[119:40.63]text. text double parenthesis title name
[119:46.80]question mark question mark title title
[119:50.96]question mark question mark parenthesis
[119:54.63]dobbold
[119:57.84]dot font dot title 2
[120:02.32]padding
[120:04.08]five
[120:06.71]we try both the name and title first if
[120:09.76]they are both nil then we Just leave it
[120:11.84]as an empty string. After we apply
[120:14.96]modifiers to make it look better. I
[120:17.67]would like the title closer to the
[120:19.11]image.
[120:20.71]Padding
[120:22.48]top,
[120:25.52]-20.
[120:28.23]Now we just need to display the
[120:29.59]description. Text title overview
[120:34.08]question mark question mark quotes
[120:38.00]padding
[120:39.92]five.
[120:42.15]This is a very simple detail screen, but
[120:44.80]it shows everything in the title strct
[120:46.80]except for the ID. As we move on, we'll
[120:50.32]add a download button and the YouTube
[120:52.40]video in place of the image. Fun fact,
[120:55.92]to make this screen, we had to use a
[120:58.23]little bit of everything from the course
[120:59.92]we've learned so far. Thank you for
[121:02.40]joining me. See you in the next one.
[121:05.59]Navigation is extremely important in
[121:07.44]Swift UI. This is because you'll want
[121:10.15]users to go to different screens in your
[121:12.08]app. Currently, the latest and greatest
[121:14.96]way to achieve this is with navigation
[121:17.11]stack. In this video, we'll show how it
[121:20.32]works by implementing it in Blossom
[121:22.08]Movie. We're going to start by seeing
[121:24.63]how buttons can drive navigation in our
[121:27.28]app. We have a hero title showing on the
[121:29.84]home screen. The play button is meant to
[121:32.56]take the user to our title detail
[121:34.15]screen. Right now, the title is just
[121:37.19]static. So, the first step is to show a
[121:39.76]different title every time the user
[121:41.28]opens the app. Since the app is called
[121:43.44]Blossom Movie, we'll use a different
[121:45.52]title from our trending movies list.
[121:47.76]Make sure you're inside view model.
[121:50.23]Under top rated TV, add a line.
[121:53.76]Type var hero title equals title preview
[121:59.59]bracket zero.
[122:01.92]This defines a new title called hero
[122:03.76]title. We initialize it using the first
[122:06.56]title in our sample data. By doing this,
[122:10.08]we'll have a fall back and we'll need to
[122:12.32]unwrap it later. Scrolling down,
[122:15.92]make a couple lines after top rated TV
[122:20.63]if flat title equals trending movies.
[122:25.04]Random element braces hero title equals
[122:30.08]title.
[122:31.84]This makes sure trending movies.rand
[122:33.28]random element isn't nil before
[122:35.44]assigning it to hero title. We're all
[122:38.08]done here. Open home view.
[122:42.15]Delete hero test title with command
[122:43.92]delete.
[122:46.88]There's an error inside async image
[122:49.19]because hero test title doesn't exist
[122:51.04]anymore.
[122:52.63]Replace hero test title with view model
[122:57.04]hero title. Poster path question mark
[123:00.23]question mark quotes
[123:02.80]poster path is an optional so we do need
[123:05.19]to unwrap it just an empty stream works
[123:08.00]for now the picture will just be a
[123:10.15]progress if nil press command R to run
[123:20.96]nice title changed I'll close and reopen
[123:24.56]the app to make sure it changes each
[123:26.40]time.
[123:33.52]Keep in mind, we're getting a random
[123:35.44]title from trending movies. Therefore,
[123:38.48]we might have some repeats.
[123:46.23]Step one is complete. Now we can get
[123:48.48]into the navigation.
[123:50.48]After we define our view model,
[123:53.44]type add state
[123:56.80]private
[123:58.32]bar title detail path equals navigation
[124:05.28]path.
[124:08.23]Add state means the UI can change this
[124:10.32]variable. Navigation path helps us
[124:13.19]manage where the user goes in our app.
[124:16.08]I'll close the log.
[124:19.28]Now we can embed our geometation
[124:21.92]stack. Make sure your canvas is open so
[124:25.04]we can use a shortcut.
[124:28.88]I'll adjust the canvas.
[124:33.11]Right click on geometry reader.
[124:36.08]embed
[124:38.56]navigation stack
[124:41.76]parenthesis path colon dollar sign title
[124:46.32]detail path.
[124:48.15]Navigation stack starts with your main
[124:50.08]screen and let you navigate to new ones.
[124:52.80]Kind of like stacking pages on top of
[124:54.56]each other. Path dollar sign title
[124:57.28]detail path tell Swift UI which screens
[124:59.67]be visited so it knows where to go and
[125:02.56]how to go back.
[125:04.80]Moving on, inside the play button
[125:07.11]action,
[125:08.88]we can put title detail path.append
[125:13.19]view model her title.
[125:16.88]This adds a new screen to the stack
[125:19.28]using hero title as a data for that
[125:21.36]screen. We do get an error because our
[125:24.15]title struck doesn't conform to
[125:25.59]hashable. To fix, open title.sswift
[125:29.28]Swift.
[125:31.11]After identifiable,
[125:33.28]put a comma
[125:35.44]hashable.
[125:37.28]Hashable let Swift tell if two items are
[125:39.76]the same. This is required when using
[125:42.23]navigation path. Let's go back to home
[125:45.11]view.
[125:47.04]And the error is gone. We can close the
[125:50.00]canvas.
[125:53.52]The last thing we need to do is add a
[125:55.59]navigation destination. Find the closing
[125:58.23]brace of our lazy vstack.
[126:00.56]Make some space dot navigation
[126:04.71]destination.
[126:06.88]Select for destination
[126:09.19]title self
[126:13.76]tab enter title tab tab title detail
[126:19.84]view title title.
[126:24.32]This tells Swift UI when we push a title
[126:27.52]onto the stack, show the title detail
[126:30.00]view with that title. It tells Swift UI
[126:33.52]knows what screen to show when we use
[126:35.67]that appending with the title. Hit
[126:38.71]command R to test.
[126:47.04]All right, our app is ready. Let's press
[126:50.07]the play button.
[126:52.88]Nice. It works. We can scroll down for
[126:56.15]the rest of the description.
[126:59.59]Our layout isn't the best. That's what I
[127:02.15]get for listening to the canvas and not
[127:04.40]testing. It's an easy fix. Open title
[127:08.00]detail view.
[127:10.80]Delete the negative padding.
[127:14.96]Run it again.
[127:24.23]Now press play again.
[127:27.28]Much better.
[127:29.92]That's all for this video. Thank you for
[127:32.32]watching.
[127:34.23]There's a good chance you'll be showing
[127:35.76]some kind of list in your app. When an
[127:38.32]item of that list is tapped, it's common
[127:40.88]to navigate to another screen passing
[127:43.11]the item data. In this video, we'll show
[127:46.80]how to achieve this using navigation
[127:49.11]paths.
[127:50.88]We want to keep the navigation logic
[127:53.04]inside home view. To do this, the tapped
[127:56.71]item needs to be accessible here. Open
[127:59.67]horizontal list view.
[128:02.00]Press enter on line 12.
[128:04.71]Type let
[128:06.88]on select
[128:08.96]colon title. Return our void.
[128:12.96]On select is a closure property that
[128:15.44]takes a title and returns nothing. The
[128:18.88]title we pass will be accessible to home
[128:21.04]view allowing it to handle navigation.
[128:24.32]Keeping that logic inside the parent
[128:26.00]view helps prevent nasty bugs. Now we
[128:29.04]need to pass the tab title to our on
[128:30.96]select property. The best place to do
[128:33.44]this is right before the for each loop
[128:35.19]ends. Here we still have access to the
[128:38.23]title that was tapped. Click the end of
[128:40.96]our dot frame modifier.
[128:43.36]Make a new line. The ontap gesture on
[128:47.28]select title.
[128:50.15]We just need to fix our preview. Scroll
[128:52.88]down
[128:54.40]after the closing parenthesis. Open
[128:56.88]brace title in. Press enter a few times.
[129:01.52]This tells a preview do nothing with the
[129:03.92]tab title.
[129:06.23]With this completed, we can go back to
[129:08.71]home view.
[129:10.32]Scroll down.
[129:12.96]We have some errors to fix due to our
[129:15.59]new on select property.
[129:18.48]After the closing parenthesis, add an
[129:21.28]open brace title in enter times two
[129:26.63]inside the braces title detail
[129:29.52]path.append
[129:31.92]title.
[129:35.04]As a quick reminder, title detail path
[129:38.00]is a navigation path we defined on
[129:40.07]top.appen
[129:42.15]puts our tap title strruct into the
[129:44.71]title detail path. This allows it to be
[129:47.52]displayed in title detail view defined
[129:50.63]below with navigation destination.
[129:54.23]We just need to fix the other three
[129:55.84]horizontal list errors. Let's copy the
[129:58.80]closure we use with trending movies.
[130:04.00]Paste it for the next three.
[130:12.07]Always good to save some time.
[130:15.19]Before we test, we can cut our
[130:17.92]navigation destination modifier.
[130:22.96]Paste it right under our task modifier.
[130:28.23]It's good practice to have this modifier
[130:30.63]as close to the navigation stack as
[130:32.40]possible.
[130:33.76]This helps us see the navigation more
[130:35.52]clearly. Go ahead and run the code with
[130:38.00]command R.
[130:45.76]Let's click on our first trending movie.
[130:50.15]Nice. It works. Let's go back and do
[130:53.04]some more testing. I'll just click on a
[130:55.59]few
[131:05.19]Good. We're able to click around and go
[131:07.84]back to our home screen.
[131:10.15]Let's also make sure the hero play
[131:11.67]button works.
[131:14.80]Do it a few times.
[131:23.44]No issues here as well.
[131:25.92]a slightly shorter video, but if you're
[131:28.32]not careful, nasty bugs happen with
[131:30.71]navigation. These can include duplicate
[131:34.15]screens and views not being dismissed.
[131:37.44]That's it for this one. Thank you for
[131:39.67]watching.
[131:41.36]You might want to display a web page or
[131:43.84]maybe a YouTube video in your iOS app.
[131:46.56]WebKit is a perfect tool to help
[131:48.15]accomplish this. This is a UI kit tool
[131:51.67]and at the time of this recording,
[131:53.92]there's no native way to do this in
[131:55.28]Swift UI. In this lesson, we'll set up a
[131:58.96]web view to display a YouTube video.
[132:01.36]This will get us one step closer to
[132:02.88]fetching and displaying trailers for
[132:05.04]each title.
[132:07.11]Before we get started, I want to point
[132:09.67]out it's not a good idea to keep
[132:11.36]sensitive information directly in the
[132:13.44]client or production apps. Firebased
[132:16.80]cloud storage or a secure backend would
[132:19.36]be a safer option. However, this is a
[132:22.71]practice app that won't be published.
[132:25.04]The goal here is to focus on learning
[132:27.19]and get better with Swift UI. With that
[132:29.76]out of the way, let's open our API
[132:32.15]config.json file. Add a comma after TMDB
[132:36.23]API key.
[132:38.71]Enter. Type parenthesis youtube
[132:43.28]base URL parenthesis colon parenthesis
[132:47.28]https
[132:49.19]colon YouTube.com
[132:52.96]slashmbbed.
[132:55.76]This will be the URL we use to show our
[132:58.40]YouTube videos.
[133:01.11]Next, open apicconfig.sswift. Swift
[133:05.36]after TMDB API key press enter. Let
[133:10.56]YouTube base URL colon string. This
[133:15.67]gives us access to the YouTube base URL
[133:17.76]string throughout our app. Please make
[133:19.92]sure your spelling matches with mine
[133:21.52]before moving on.
[133:24.32]Make a new file with command N. Swift
[133:27.36]file. Next. YouTube
[133:31.19]player. Great.
[133:35.59]We don't need import foundation here. I
[133:38.40]can replace it with import swift UI.
[133:41.59]Also add import web kit. Add a couple
[133:45.67]lines. Type strruct
[133:49.28]YouTube player colon ui view
[133:53.52]representable
[133:55.84]with braces.
[133:58.23]UI view representable lets us wrap a UI
[134:00.56]kit view and use it inside Swift UI.
[134:05.04]Inside the braces, type lat web view
[134:08.71]equals UK web view enter let video ID
[134:15.11]colon string enter let YouTube
[134:22.07]base URL equals API config.shared shared
[134:27.52]YouTube base URL
[134:30.07]UK web view creates an instance of a web
[134:32.63]browser but inside the app we'll use the
[134:35.76]video ID and YouTube base URL to load
[134:38.96]our videos inside it make some space and
[134:42.40]type funk make UI view context context
[134:47.11]return some view UI view inside the
[134:50.40]braces type web view this function is
[134:53.52]part of the UI view representable
[134:55.19]protocol
[134:56.48]It's called once our Swift UI view is
[134:58.15]created and tell Swift UI this is a UI
[135:01.36]kit I want you to use. In our case, show
[135:04.56]the web view we just made.
[135:08.23]Down arrow once. Add a couple more
[135:11.11]lines. Funk update UI view. UI view UI
[135:16.40]view type context context with braces.
[135:20.00]Another part of the UI representable
[135:21.92]protocol. This one gets called whenever
[135:24.07]Swift UI updates the view. We'll load
[135:26.56]our video here into the web view.
[135:30.15]Inside the braces, type guard lat base
[135:34.00]URL string equals YouTube base URL,
[135:39.04]comma, enter, let base URL equals URL
[135:45.19]parenthesis string
[135:47.44]base URL string
[135:51.19]else bracket return.
[135:56.56]This first unwraps the YouTube base URL
[135:58.63]string from our API config ensuring it's
[136:01.67]not nil. Then we convert the string into
[136:04.71]a URL. Also making sure it's not nil. If
[136:08.32]either of them are nil, we safely exit
[136:10.88]the function.
[136:13.28]Below that add let URL equals base URL
[136:19.52]appending path
[136:23.11]video ID.
[136:25.28]Enter web view.load
[136:29.19]URL request
[136:32.00]parenthesis URL
[136:34.63]full URL.
[136:37.43]We complete our YouTube URL by appending
[136:40.08]the video ID. Then we have web view load
[136:43.51]this URL.
[136:45.67]This completes the file. Let's now open
[136:48.39]title detail view.
[136:51.67]Delete async image.
[136:56.71]Add YouTube player video ID.
[137:00.80]Paste this ID in there. It's one of our
[137:03.43]most popular YouTube shorts.
[137:06.31]Add the modifier
[137:08.47]aspect ratio. Select aspect ratio and
[137:12.00]content mode. 1.3 for aspect ratio. Tab.
[137:18.39]Do fit for content mode. This modifier
[137:21.67]makes sure the video keeps the correct
[137:23.12]shape and scales proportionally.
[137:25.92]4x3 or 1.3 is a YouTube classic embedded
[137:30.71]video ratio. Hit command R to run.
[137:38.16]The simulator is up. Click on any movie
[137:40.80]title.
[137:43.20]Perfect. We have our web player showing
[137:45.51]front and center. Press play. Need an SF
[137:49.51]symbol.
[137:51.51]And it works.
[137:54.16]Right now, all the titles will have the
[137:56.39]same video, but the next step is to work
[137:58.80]with the YouTube API to get the trailers
[138:01.28]for each title. Thank you for watching
[138:03.59]this video. See you in the next one.
[138:07.12]Google along with Apple is one of the
[138:08.71]main forces in the mobile development
[138:10.96]space. As an iOS developer, there's a
[138:14.71]good chance you'll use a Google product
[138:16.31]at some point. This could take form with
[138:18.96]Google O, Firebase or Google API.
[138:23.35]In this video, we're going to start
[138:25.43]working with the YouTube API. This
[138:27.84]includes getting our API key from the
[138:29.51]Google Developer Console as well as
[138:32.16]modeling the return JSON data. The first
[138:35.12]step in our journey is to get our
[138:36.47]credentials. Open your favorite browser.
[138:40.16]Type Google Developer Console in the
[138:41.92]search bar. Open the first link.
[138:48.16]If you haven't already, please make
[138:50.24]yourself a Google account. Once you have
[138:52.63]one, click on create project.
[138:56.39]I'll call this project Blossom Movie.
[139:01.92]Create.
[139:08.39]With the project created, navigate to
[139:10.88]library.
[139:14.24]Find YouTube data API v3.
[139:19.20]Open it.
[139:21.20]Enable.
[139:27.35]Now we just need to create credentials.
[139:33.20]We're going to be using public data.
[139:36.88]Next,
[139:40.24]we have our key ready to go. Go ahead
[139:42.63]and copy it.
[139:45.04]Let's go back to Xcode.
[139:48.72]Open APIconfig.json.
[139:52.08]Put a comma after YouTube base URL.
[139:55.84]Enter
[139:58.31]parenthesis YouTube
[140:01.28]API key parenthesis colon double
[140:05.28]parenthesis. Please paste your API key
[140:07.84]in here. I'm going to put in your key as
[140:11.43]a placeholder.
[140:13.20]While we're here, we might as well
[140:15.20]define the YouTube search URL.
[140:18.47]Add a comma after the YouTube key. Enter
[140:22.39]parenthesis YouTube
[140:25.20]search URL
[140:28.08]parenthesis colon parenthesis.
[140:31.68]I'll paste the URL here to save some
[140:33.43]time. It'll be in the description if you
[140:35.60]want to grab it. With our new properties
[140:37.92]in the JSON file, we just need to find
[140:40.64]them in API config.sswift. Swift.
[140:44.39]Make a new line after YouTube base URL.
[140:48.08]Let YouTube API key colon string. Enter.
[140:53.52]Let YouTube
[140:57.43]search URL colon string. Please make
[141:01.68]sure your spelling matches with mine
[141:03.52]before moving on. The next step is to
[141:06.00]model our JSON data. I'll bring up an
[141:08.96]example of what a YouTube search car
[141:10.72]returns.
[141:12.00]This is the data we're working with.
[141:14.24]We're going to conduct a YouTube search
[141:16.16]on the title name and the word trailer.
[141:19.28]The only element that enters us here is
[141:21.43]video ID inside the items array. This
[141:24.72]video ID will be passed to our YouTube
[141:26.31]player to show the trailer. We'll simply
[141:29.60]use the first ID as it's most likely to
[141:32.24]be the correct video. Let's head back to
[141:34.88]Xcode. Command N for a new file.
[141:39.12]Swift file. Next,
[141:42.96]YouTube.
[141:45.92]Search response.
[141:48.96]Create.
[141:52.00]I find it easier to start from the
[141:53.68]bottom when modeling NSA data set
[141:58.39]ID properties
[142:01.52]colon codable
[142:04.08]with braces
[142:06.39]let video ID
[142:10.08]colon string question mark. This models
[142:13.43]the last layer getting our video ID.
[142:16.56]It's a good idea to make these
[142:17.76]properties optionals in case the
[142:19.92]database returns null.
[142:22.47]We can go to the next layer up which is
[142:24.96]an object named ID. Make room at the top
[142:27.92]of ID properties
[142:30.08]strct
[142:31.84]item properties
[142:34.24]colon codable
[142:36.16]let id colon id properties question
[142:39.68]mark.
[142:41.60]We just need the top layer
[142:44.39]strct
[142:46.16]YouTube search response colon codable.
[142:49.68]The top layer has an array that contains
[142:52.00]item properties. Therefore, we can type
[142:55.28]let items
[142:58.08]colon bracket item properties
[143:03.52]bracket question mark.
[143:07.35]The str names themselves don't matter as
[143:09.68]much as the property names. Property
[143:12.00]names have to match the JSON data or
[143:14.39]else the app will crash. I'll bring up
[143:16.80]our working data one more time.
[143:22.24]Starting from the top, we have an array
[143:24.56]of items that contains an object called
[143:27.76]ID.
[143:29.28]Inside ID, we're able to get the video
[143:32.08]ID.
[143:34.16]We're all done here. Everything is set
[143:36.56]up and the next step is to parse the
[143:38.80]data. Thank you for watching.
[143:43.28]Something about programming is that
[143:44.88]although rewarding, it tends to be a bit
[143:47.12]repetitive.
[143:48.47]For example, in our app, we already saw
[143:51.12]how to model an API response, build a
[143:53.60]URL, and parse the response. In the
[143:56.88]pursuit of working with the YouTube API,
[143:59.20]we already modeled the response. Now, we
[144:01.92]must complete the next two steps,
[144:03.92]building the URL and parsing. This will
[144:07.28]be the main topic of this video. It's
[144:10.00]good to remember that practice does make
[144:11.68]perfect. To start, open dataf
[144:15.04]fetcher.sswift. Swift.
[144:18.08]We need to define our new variables
[144:20.56]under TMDB API key.
[144:24.00]Let YouTube
[144:26.80]search URL equals API config.shared
[144:32.64]YouTube search URL. Enter. Let YouTube
[144:38.16]API key equals API config.shared shared
[144:43.04]that YouTube API key.
[144:45.92]To recap, our end goal is to show the
[144:48.72]YouTube trailer for each title in the
[144:50.64]detail screen. By using the YouTube API,
[144:54.24]we can get the trailer video ID and pass
[144:56.88]that in the YouTube player we made
[144:58.31]earlier.
[144:59.84]Now, we can create a function to build
[145:02.00]the URL and parse the data. Scroll all
[145:05.43]the way down.
[145:07.20]Click after the second to last curly
[145:08.96]brace. Hit enter a couple times. We'll
[145:12.96]make this its own function since it's a
[145:15.28]different API.
[145:17.60]Punk fetch video ID parentheses for
[145:23.52]title colon string close parenthesis
[145:27.84]async throws return error string.
[145:32.64]This function takes in a string called
[145:34.16]title. It also makes a network call and
[145:37.28]could throw an error. Therefore, async
[145:39.60]and throws are needed. The function
[145:41.76]returns a string at the end.
[145:44.72]Inside the braces, we need to first
[145:47.20]unwrap the YouTube URL and key guard let
[145:52.16]base search
[145:54.96]URL equals YouTube search URL
[145:59.68]else braces throw
[146:03.84]network error. Missing config. Down
[146:07.28]arrow. Enter twice. Guard flat.
[146:12.88]Search API key equals YouTube API key
[146:19.12]else braces throw network error
[146:24.56]missing config.
[146:28.31]The next step is to build our URL. I
[146:31.35]actually want to show a different way to
[146:32.88]accomplish this without hard coding like
[146:35.20]we did in the movie database. Open
[146:37.76]constants
[146:40.31]right after the closing brace. Make some
[146:43.12]space and scroll down.
[146:48.00]enum YouTube URL string colon string
[146:54.08]with braces
[146:56.16]case trailer
[146:58.88]equals parentheses trailer
[147:03.43]case query shortened
[147:08.00]equals parenthesis q
[147:13.04]space
[147:14.72]equals
[147:17.04]parenthesis
[147:18.08]space
[147:20.72]case key equals parenthesis key.
[147:27.43]Using enims this way to group related
[147:29.43]strings helps prevent typos, encourages
[147:32.31]reusability, and keeps things neat. I
[147:35.84]wanted to show a better way than just
[147:37.60]hard- coding the values. I used this
[147:40.08]method in another project, and it's been
[147:42.39]pretty good.
[147:44.31]It should actually be YouTube. You're
[147:46.31]all strings.
[147:48.64]Going back to data fetcher
[147:51.35]under search API key.
[147:54.80]Let trailer search
[147:57.84]equals title plus YouTube URL
[148:03.20]strings.space.
[148:06.31]Value plus YouTube all
[148:10.08]strings.tra.value.
[148:12.39]value. This is one query we'll make to
[148:15.60]the API.
[148:17.52]Make some space. Time to finally build
[148:20.08]our URL.
[148:21.84]Guard lamp fetch video URL
[148:26.47]equals URL
[148:29.28]parenthesis string
[148:32.08]base search URL
[148:34.96]appending
[148:37.04]query items
[148:38.88]URL query items. Press enter. After
[148:44.24]the first bracket, press enter.
[148:48.72]Press enter again after the closing
[148:50.31]bracket.
[148:52.47]This spaces it out, making it easier to
[148:54.64]read. We can now add our query items.
[148:59.43]I'll scroll down a bit first. Add a
[149:02.16]parenthesis after URL query item.
[149:06.00]Select name and value for name. YouTube
[149:10.24]URL strings dotquery shortened raw value
[149:15.12]tab trailer search
[149:19.35]right arrow add a comma to add another
[149:22.08]query item press enter first for better
[149:25.04]spacing
[149:26.56]URL query item name and value YouTube
[149:31.60]url strings
[149:33.68]key dot raw value tab search API key.
[149:40.72]We just need to complete the guardlet
[149:42.31]statement after the closing parenthesis
[149:45.68]else with braces
[149:47.76]throw network error dot URL build
[149:52.24]failed.
[149:54.47]After we build the URL,
[149:56.96]add print
[149:59.20]fetch video URL.
[150:02.24]This will help us check the URL in the
[150:04.47]console.
[150:06.16]To help us see this more clearly, I'm
[150:08.56]going to paste the URL that we just
[150:10.08]built using Breaking Bad as an example.
[150:14.80]The first part is our base URL.
[150:17.68]We then add our first query represented
[150:20.00]by the Q and the trailer search string
[150:22.16]we built. The second query is our API
[150:25.04]key.
[150:27.04]I did want to tackle parsing in this
[150:29.12]video, but I actually think this is a
[150:31.60]good place to stop for now. Thank you
[150:34.08]for watching.
[150:36.47]Parsing API JSON responses is one of
[150:39.35]those things that keeps coming back.
[150:41.43]We've already seen how to do it with the
[150:42.96]movie database, but this time we're
[150:45.60]taking it a step further. In this video,
[150:48.80]we're going to refactor that code and
[150:50.96]make it reusable using Swift Generics.
[150:53.68]With the refactored code, we'll be able
[150:56.24]to parse our YouTube API response.
[150:59.84]We can open data fetcher to start.
[151:04.96]Parsing the response and our fetch
[151:06.72]titles function starts from let data you
[151:10.31]response to var titles. This code will
[151:14.08]be similar to parsing the YouTube
[151:15.60]response. The only difference being what
[151:18.47]object we return. We could just copy and
[151:21.28]paste the code down to our fetch video
[151:23.12]ID function. However, this is the
[151:26.24]perfect moment to introduce Swift
[151:27.92]generics. This can also be good code for
[151:30.96]later projects.
[151:33.04]Let's make some space after the fetch
[151:34.88]title closing brace.
[151:37.92]We'll make the function here first. Test
[151:40.39]it. Then call it for the YouTube
[151:42.39]response.
[151:43.92]Funk fetch and decode.
[151:48.31]Left arrow T colon decodable
[151:52.47]right arrow
[151:54.31]parenthesis URL colon URL
[151:58.64]comma type colon type
[152:04.64]parenthesis async throws
[152:08.31]return arrow
[152:10.56]t with braces.
[152:15.04]T col decodable lets the function know
[152:17.60]that the struck we're working with must
[152:19.35]conform to decodable. We pass in two
[152:22.16]arguments a URL and a strruct using
[152:25.20]t.type.
[152:26.80]t.type means we're passing a generic
[152:28.72]strruct that we want to decode like API
[152:31.92]object self. The function will perform a
[152:35.04]network request and can throw an error
[152:37.76]which is why async and throws are
[152:39.84]needed. Finally, it will return a strct
[152:43.52]represented by T.
[152:45.84]Select from lat data UR response to V
[152:49.52]titles cut with command X.
[152:53.35]Paste it inside our fetch and decode
[152:55.28]function.
[153:00.00]We just need some adjustments. Replace
[153:02.64]fetch titles URL with URL.
[153:07.43]Delete bar titles equals at the end.
[153:13.76]replace with return
[153:16.72]API object should be tel
[153:20.96]finally delete results.
[153:26.64]We replace our hard-coded values with
[153:28.64]the arguments we pass into the function.
[153:31.28]Here's a quick recap of what this code
[153:33.20]does. We use try await URL sessions that
[153:37.12]share that data to fetch data from the
[153:39.68]URL passed into the function. This gives
[153:42.72]us both data and a URL response.
[153:46.31]Then we unwrap the response and make
[153:49.04]sure it's a HTTP URL response with a 200
[153:52.88]status code. If it's not, we throw a
[153:56.16]custom nextstep error that describes
[153:58.47]what went wrong. After that, we define a
[154:01.92]JSON decoder and tell it to use doc
[154:04.39]convert from snake case. This is needed
[154:07.12]since our JSON keys are snake case, but
[154:09.76]our swift strrus use camel case. Lastly,
[154:14.00]we use that decoder to try and return
[154:15.92]the object type T from the URL data. T
[154:19.52]is the generic type we pass into the
[154:22.16]function. We can actually replace this
[154:24.47]with type since we already defined the
[154:26.64]variable.
[154:33.43]Now we just need to call this function
[154:34.96]and fetch titles. Click under print
[154:37.76]fetch titles URL
[154:39.92]bar titles
[154:42.16]equals try08
[154:45.28]fetch and decode
[154:48.31]fetch titles URL
[154:50.88]API objects self dot results.
[154:57.20]Going back to title.sswift
[155:00.47]remember that API object has a variable
[155:03.12]called results and that's where the
[155:05.12]titles live.
[155:06.64]I think a rename is in order because
[155:08.72]we're now working with two APIs.
[155:11.35]Right click API object,
[155:14.00]refactor, rename.
[155:18.80]Add TM DB
[155:22.39]at the front. Enter.
[155:26.08]Navigate back to data fetcher.sswift.
[155:30.00]To clean up our strruct a bit more,
[155:32.31]let's move the helper function to the
[155:34.08]end. Select fetch and decode and build
[155:38.16]URL.
[155:41.35]Command X.
[155:43.68]Paste them under fetch video ID.
[155:49.84]The final step is to use our new
[155:51.43]function to finish fetch video ID.
[155:54.88]Select after the print statement.
[155:57.68]Make some space.
[156:00.00]Return try 08. fetch and decode fetch
[156:06.16]video URL
[156:08.39]YouTube
[156:11.12]search response
[156:13.04]self
[156:14.80]do items do first
[156:18.31]id dot video ID question mark question
[156:22.24]mark quotes
[156:26.56]we pass in the YouTube search response
[156:28.39]struck this time remember this strct is
[156:31.43]pretty nested
[156:32.72]It returns a list of items. So, we grab
[156:35.28]the first item in the array. From there,
[156:38.16]we drill down to video ID, chaining each
[156:40.80]level with a question mark to safely
[156:43.12]unwrap. If anything in the chain is nil,
[156:46.39]we return an empty string using a double
[156:48.96]question mark operator. We're done with
[156:51.43]parsing the API responses. The fetch
[156:54.16]video ID funk isn't hooked up anywhere,
[156:56.39]but we can still test to make sure our
[156:58.39]new function works for fetch titles.
[157:01.20]Please update your TMDB key inside
[157:03.28]apeconfig.json before running. Hit
[157:06.16]command R.
[157:11.76]Our simulator is up and everything
[157:13.68]loaded correctly. Click around to make
[157:16.56]sure everything is working.
[157:26.31]Good job with this. Thank you for
[157:28.56]watching and I'll see you in the next
[157:30.39]one. In our app so far, we've done a lot
[157:33.84]of leg work to get the YouTube API
[157:36.16]going. After modeling, URL building, and
[157:40.47]parsing, all that is left is to hook
[157:43.20]everything up. Although slightly
[157:45.68]controversial, we'll be using model,
[157:48.47]view, view, model to get everything up
[157:51.04]and running.
[157:52.56]Lucky for us, we've already built the
[157:55.12]MVVM structure in our app. That was the
[157:58.31]hard part. Adding more logic is much
[158:00.96]easier. Open view model.sswift.
[158:05.92]Press enter after the home status enum.
[158:10.56]We'll make a new enum to keep track of
[158:12.88]the video ID fetch state. private
[158:18.31]set
[158:20.56]bar
[158:22.56]video ID status colon fetch status
[158:27.12]equals dot not started.
[158:30.08]Let's press enter to space it out
[158:31.84]better.
[158:33.43]Make a new line under hero title
[158:37.04]bar video ID equals quotes.
[158:43.12]We'll use this property to hold the
[158:44.72]string that our YouTube API fetches.
[158:48.00]Find the closing get titles brace.
[158:51.20]Press enter a couple times after it.
[158:54.47]Funk get
[158:56.96]video ID or title colon string
[159:03.76]async with braces.
[159:07.52]This function will be called in the UI
[159:09.28]to retrieve the video ID.
[159:11.68]We can set the status to fetching when
[159:13.52]called.
[159:15.12]Video id status
[159:17.60]equals batching.
[159:20.47]Create a do catch block under that.
[159:25.76]This will help us handle errors. Inside
[159:28.88]do we can call the API
[159:32.24]video ID equals try8
[159:36.80]data fetcher. Fetch video ID for title
[159:42.96]video ID status equals success.
[159:48.47]We set this if everything goes well.
[159:51.43]Inside catch, we can print the error to
[159:54.08]our log.
[159:56.96]In addition, set the status to failed.
[160:03.43]Don't forget to pass the error for
[160:05.12]underlying error.
[160:07.12]This completes the view model. All
[160:09.35]that's left is to hook it up to our UI.
[160:12.39]Open title detail view.
[160:16.16]There are a few things I want to do here
[160:18.24]to make our code better on top of adding
[160:20.80]the feature. To start off, let's create
[160:24.16]a computer property of our title name.
[160:26.96]Make a new line after title
[160:29.68]bar title name colon string with braces.
[160:36.96]Inside the braces, type return
[160:39.84]parenthesis title.name
[160:42.88]question mark question mark title.title
[160:47.68]parenthesis question mark question mark
[160:50.16]quotes.
[160:52.16]This is the first time we've seen
[160:53.60]computer properties. It's a great way to
[160:56.16]add custom logic to your models without
[160:58.56]storing extra data.
[161:00.80]This logic tries to return their name or
[161:03.12]title first. If they are nil, an empty
[161:06.96]string is returned instead.
[161:09.35]Our API uses names for movies and titles
[161:12.39]for TV shows. So, we test for both.
[161:16.31]Under this computer property, make a new
[161:18.88]line. Let
[161:21.76]view model equals
[161:24.88]view model.
[161:27.43]Our view model will control the UI
[161:29.76]depending on the API call result. Find
[161:32.88]the closing brace and scroll view
[161:36.47]from the closing brace through the open
[161:38.96]brace. Press command X to cut.
[161:43.12]This code will be used if the call
[161:44.80]succeeds.
[161:46.56]Inside the geometry brace type switch
[161:50.96]view model
[161:53.35]dot video id status
[161:57.28]Xcode completes the cases for us
[162:00.56]inside
[162:02.24]put empty view.
[162:07.20]We can tab over do fetching will just
[162:10.31]show a progress view.
[162:12.96]Add a line and add dot frame width and
[162:16.56]height
[162:18.16]for width. Geometry dots size dowidth
[162:23.04]tab geometry dots size doheight.
[162:28.08]This puts the progress view in the
[162:30.00]center
[162:31.92]inside case.
[162:33.92]Paste the UI code we cut.
[162:36.96]Replace video ID inside the YouTube
[162:39.04]player with
[162:42.00]view model
[162:43.92]dot video ID.
[162:46.96]We can also use title name inside text.
[162:53.68]Finally inside case.failed
[162:57.92]type text underlying error.lo
[163:02.24]description.
[163:03.76]For now, we just showed what error took
[163:06.31]place, but we'll make this more user
[163:08.39]friendly later.
[163:10.24]The last thing to do is to call a view
[163:11.76]model to fetch the video ID.
[163:14.39]After the geometry reader brace,
[163:18.39]make a new line.
[163:20.80]Task with braces
[163:24.56]view model
[163:26.47]get video ID or title name.
[163:32.31]Before we test, please make sure you
[163:34.64]update your API keys in API config.json.
[163:38.88]Hit command R to run.
[163:43.92]The app is ready. Click on the play
[163:46.16]button from the hero title.
[163:51.68]Nice. The video loads and it looks like
[163:54.64]it grabbed the correct trailer. Press
[163:56.96]play
[164:01.52]and it works.
[164:04.96]Go back.
[164:07.20]Let's try a train TV title.
[164:12.96]Perfect. Also looks great. Just a heads
[164:16.72]up with the YouTube API. Google limits
[164:19.52]the API calls per day. If you open
[164:22.39]enough titles, you'll get an error at
[164:24.88]some point. That's it for this video.
[164:28.00]Thank you so much for watching.
[164:30.56]With making iOS apps, there's a good
[164:33.20]chance you need different style of list.
[164:35.84]We already saw how to make a horizontal
[164:37.76]list. In this video, we'll make a
[164:40.56]vertical list in Swift UI, expanding our
[164:43.04]tool set. Let's start by making a new
[164:46.08]file with command N. Swift UI view.
[164:49.68]Next, vertical list view. create.
[164:58.00]Click on line 10. Enter.
[165:01.76]We can define an array of titles to use
[165:03.92]for the list. bar titles colon bracket
[165:08.08]title.
[165:10.39]We get an error because the preview
[165:12.64]needs a list of titles to use. Select
[165:15.12]the error fix
[165:18.64]pass title.
[165:20.96]Preview titles.
[165:23.76]Make a new line after titles.
[165:26.96]Delete the famous hello world
[165:30.64]list parenthesis titles
[165:33.52]parenthesis bracket title n inside the
[165:37.27]list braces async image URL URL
[165:42.31]parenthesis string
[165:45.20]title poster path question mark question
[165:48.24]mark quotes.
[165:50.80]We make a new list and pass our titles
[165:52.96]in. Then we show each title poster with
[165:55.92]async image by converting the poster
[165:58.16]path to a URL. Modifiers are needed on
[166:01.43]our async image. Right arrow twice
[166:04.64]bracket image in enter. Enter.
[166:09.04]Right arrow placeholder
[166:11.76]progress view.
[166:15.20]This shows a progress circle as the
[166:16.88]image loads. If the poster path is nil,
[166:20.31]we pass an empty string. That just keeps
[166:22.64]the progress view going. Go back in the
[166:25.12]async image brace. Image entertizable
[166:30.72]dots scale to fit dot clip shape.
[166:35.92]Rect
[166:38.24]corner radius
[166:40.80]10
[166:42.39]dot padding
[166:44.56]five.
[166:47.20]These modifiers allow the image to be
[166:49.27]resized to fit within the space given.
[166:52.72]Make the corners round by a radius of 10
[166:55.76]and add space around at five points. We
[166:58.88]want the title names to be next to the
[167:00.39]poster. Therefore, right click on image
[167:04.72]embed h stack.
[167:08.47]Make some space after padding five
[167:11.92]text parenthesy parenthesy title.name
[167:15.52]name
[167:17.04]question mark question mark title.title
[167:20.96]parenthesy question mark question mark
[167:24.08]quotes.
[167:26.31]A title could have a name or title
[167:28.47]property depending if it's a movie or TV
[167:30.88]show. We try both and if they're null,
[167:34.24]an empty string is passed. Let's add a
[167:37.20]couple of modifiers to the title.
[167:39.84]font.system
[167:42.24]size 14.bold.
[167:47.20]By putting our title inside the async
[167:49.20]image closure, it won't show unless the
[167:52.00]poster loads.
[167:53.84]Click after the placeholder brace. Enter
[167:57.52]frame height
[168:00.16]150.
[168:02.00]This keeps the list items no more than
[168:04.08]150 points tall. Since no width is
[168:06.96]specified, each item takes up as much
[168:09.60]space needed horizontally.
[168:12.24]The list looks great, we can use it in
[168:14.96]our app, but only with sample data for
[168:17.27]now. Make a new file with command N.
[168:20.47]Swift UI view. Next, upcoming view.
[168:25.84]Create.
[168:28.56]Delete. Hello world.
[168:31.43]Vertical list view. titles title
[168:36.80]preview titles.
[168:38.96]This seems like overkill to just call
[168:41.12]this in our content view. In the future,
[168:44.47]there will be logic here that can make
[168:46.39]our content view messy.
[168:48.96]Navigate to content view.
[168:51.76]Delete text contents upcoming string.
[168:56.24]Replace with upcoming view.
[168:59.52]Press command R to run.
[169:02.08]Our
[169:07.27]app is up and running. Click on
[169:09.27]upcoming.
[169:11.27]Nice. We have our sample data showing as
[169:13.76]a vertical list. We still need to add
[169:16.31]navigation and of course real API data.
[169:20.56]This is the first time we work on
[169:22.16]another tab in the app. So, great job.
[169:25.20]We're done here. Thank you for watching.
[169:28.24]At this point in the tutorial, our
[169:30.64]vertical list is built. However, it's
[169:33.60]still only showing test data. In this
[169:36.39]video, we'll populate it using our API
[169:39.52]and display a list of upcoming movies.
[169:42.56]Open data fetcher.
[169:45.92]I'll paste the URL we'll populate our
[169:48.31]vertical list with
[169:51.43]this URL is identical to our top rated
[169:53.52]URL with the only difference being
[169:55.92]upcoming instead of top rated.
[169:59.20]We'll have to adjust our build your
[170:00.96]function to construct this correctly.
[170:03.84]Scroll down
[170:06.96]inside the else if statement. Type or
[170:11.68]type
[170:13.27]double equals upcoming.
[170:17.35]Replace top rated with backslash
[170:21.35]parenthesis type.
[170:24.39]This will build the correct URL when top
[170:26.88]rated or upcoming are passed for the
[170:29.68]type. To make our code a bit better,
[170:33.04]delete trending in the first if
[170:34.56]statement
[170:36.72]backslash parenthesis type.
[170:40.39]The less hard-coded strings, the better.
[170:43.84]Our build URL function can now make the
[170:46.47]upcoming URL.
[170:48.47]With this, we can open our view model.
[170:53.12]Make a new line after video ID status
[170:56.96]private
[170:59.35]parenthesis set bar upcoming
[171:04.16]status
[171:06.24]fetch status equals dotn not started.
[171:10.08]We'll use this enum to keep track of the
[171:12.31]upcoming titles fetch state.
[171:15.35]A new array is also needed to hold the
[171:17.27]upcoming movies. This can be placed
[171:19.92]after top rated TV.
[171:23.12]bar upcoming movies colon bracket title
[171:28.24]equals empty brackets.
[171:30.64]By making this array empty, we won't
[171:33.52]need to unwrap it later.
[171:36.08]Since this call will not be on the home
[171:37.84]screen, we can make a new function for
[171:40.08]it. Scroll all the way down. Make some
[171:43.52]space after the get video ID function.
[171:47.76]funk get upcoming movies
[171:52.24]parenthesis async with braces.
[171:55.52]Inside the braces, we can set upcoming
[171:58.39]status equal to fetching.
[172:02.08]Then we can make a do catch block
[172:08.72]inside do upcoming movies equals try
[172:13.76]await data fetcher. Match titles for
[172:17.84]movie
[172:19.43]by upcoming
[172:22.80]try as needed because this function can
[172:25.20]throw errors and a wait allows it to run
[172:28.24]in the background not blocking the UI.
[172:32.24]If this call completes upcoming status
[172:36.24]equals success.
[172:39.04]Now we just need to complete the catch
[172:40.47]statement.
[172:42.31]print error
[172:45.60]upcoming status equals failed underlying
[172:50.39]error error. We print the error in our
[172:53.92]console for debugging and then pass the
[172:56.47]error in our enum for the UI. Everything
[172:59.20]is ready to go here. We just need to
[173:01.43]hook it up to our UI. Open upcoming
[173:04.31]view.swift.
[173:06.80]Make a couple of lines after line 10.
[173:10.96]Let view model equals view model.
[173:16.80]Delete the preview titles.
[173:21.04]Replace with view model.upcoming
[173:23.76]movies.
[173:25.52]Make some space before this line.
[173:28.72]Switch view model upcoming status.
[173:33.76]This allows us to define a view for each
[173:36.00]state.
[173:37.60]In do not started. We can put empty view
[173:41.92]dot fetching is progress view
[173:46.16]cut the vertical list view code
[173:51.27]paste it inside dots success.
[173:54.31]Lastly text
[173:57.52]underlying error.lo description works
[174:01.27]great for case.failed.
[174:03.76]The progress view should be in the
[174:05.20]center of our view when it loads. Before
[174:07.68]the switch statement
[174:09.92]geometry reader brace go n
[174:14.64]delete the closing brace put it after
[174:17.52]the switch closing brace.
[174:22.16]Add a frame in progress view
[174:25.12]frame width and height go.
[174:29.84]Dow width
[174:31.68]go. size the height.
[174:35.84]This puts the progress view in the
[174:37.52]center of the screen.
[174:39.68]All that's left is to populate the data.
[174:42.24]Bind the geometry reader closing brace
[174:45.43]entertask
[174:47.52]with braces.
[174:49.43]Inside the braces
[174:52.16]view model get upcoming movies.
[174:56.16]This populates the upcoming movies
[174:57.76]array.
[174:59.27]Before running, please make sure to
[175:01.43]update your API keys inside API
[175:03.84]config.json.
[175:05.68]Hit command R to run.
[175:13.12]Our app is up and running. Navigate to
[175:15.68]upcoming.
[175:17.68]Nice. The data populates.
[175:21.20]We can scroll down
[175:23.43]and everything is in working order. If
[175:26.24]you're thinking it's getting easier to
[175:28.39]set everything up, you'd be right. A lot
[175:31.68]of the infrastructure was done in
[175:33.12]section 2, allowing our new features to
[175:35.60]be added faster. That's it for this
[175:38.31]video. Thank you for watching.
[175:41.84]Navigation is a critical aspect in any
[175:44.16]app. Like most things, there are a few
[175:47.20]ways to accomplish this. We already saw
[175:49.68]one way by using navigation stack and
[175:52.08]navigation path in the home screen. In
[175:54.64]this video, we'll demonstrate how to use
[175:56.96]navigation links with navigation stack
[175:59.43]for the upcoming screen. To start, let's
[176:03.04]open the parent view, which would be
[176:05.04]upcoming view.
[176:08.24]We need to embed this view into a
[176:10.39]navigation stack. Right click on
[176:12.72]geometry reader,
[176:14.72]embed,
[176:17.35]navigation
[176:19.84]stack.
[176:21.68]This allows us to enable navigation
[176:24.08]within our view. For example, tapping a
[176:27.60]list item can now push a new screen into
[176:30.39]the stack. The next step is to define a
[176:33.43]navigation link inside the child view.
[176:36.72]Open vertical list view.
[176:39.52]Make some space before async image.
[176:43.43]Navigation link with braces.
[176:47.43]Define a label after the closing braces.
[176:52.47]Inside the navigation link braces, we
[176:54.96]need to define our destination.
[176:57.35]Title detail view title title. This
[177:00.96]passes the title tapped before going to
[177:03.60]title detail view. Label defines how the
[177:06.56]navigation link is shown. The UI for the
[177:09.27]vertical list will do. Great. Select
[177:11.68]from async image till frame. Cut. paste
[177:16.64]it inside label.
[177:20.80]To recap, we add a navigation stack to
[177:23.60]the parent view. Then we add a
[177:26.47]navigation link inside the child view.
[177:29.20]Navigation link lets us define where the
[177:31.12]user goes and how the link looks using
[177:33.84]label. Please make sure the API keys are
[177:36.56]updated inside APIconig.json.
[177:40.08]Press command R to run.
[177:45.12]The app is up. Select upcoming.
[177:49.43]Notice there are arrows on the right
[177:51.68]showing a clickable list. Click on the
[177:54.24]title.
[177:56.96]The title detail view opens correctly.
[178:00.16]I'll test a few more titles.
[178:09.60]Everything seems to be in working order.
[178:12.39]Let's go to the home tab while on a
[178:14.56]title detail in the upcoming tab. Click
[178:17.43]on the title.
[178:20.47]Go back to upcoming
[178:24.08]the detail screen maintained and
[178:25.52]upcoming. If we go back to home,
[178:29.84]the detail screen also maintained there.
[178:33.04]I do want to talk about navigation path
[178:35.43]versus navigation link to finish the
[178:37.60]video. Although navigation link is much
[178:40.64]simpler to use compared to navigation
[178:42.31]path, it comes with a few drawbacks.
[178:45.27]First, it's a little too eager to make
[178:47.43]the views. This can happen sometimes
[178:50.24]even when an item or button isn't
[178:51.92]tapped. Therefore, performance issues
[178:54.72]can occur.
[178:56.56]Second, navigation link only works with
[178:59.35]user interaction. You can't use it to
[179:02.00]navigate after loading data or handling
[179:04.39]things like deep links or push
[179:06.16]notifications.
[179:07.76]That means no async navigation and no
[179:10.64]programmic control. All that being said,
[179:14.16]navigation link does work and it's
[179:16.31]really simple to use. I think it's good
[179:18.72]for practice apps where the point is to
[179:21.04]work on other big features and keep
[179:23.20]navigation simple. However, for
[179:26.08]production apps, I would lean towards
[179:28.39]navigation path to keep performance and
[179:31.12]overall user experience tight. I wanted
[179:34.00]to show you both ways to give you more
[179:36.08]options.
[179:37.43]That wraps up this video. Thank you so
[179:39.92]much for watching. We officially
[179:42.16]finished the second tab on the app and
[179:44.39]are pretty close to completion. I can't
[179:46.88]wait to see you in the next one.
[179:49.43]We've seen how to build horizontal and
[179:51.76]vertical lists. In this tutorial,
[179:54.16]sometimes your app might instead need a
[179:56.64]grid layout with rows and columns of
[179:58.88]content. That'll be the main topic for
[180:01.20]this video, creating the UI for grid
[180:04.64]style list.
[180:06.56]This is going to be the third tab of our
[180:08.47]app that will contain the search
[180:10.31]feature. Therefore, we'll need to create
[180:13.20]a new file. Press command N. Swift UI
[180:17.27]view. Next, search view. Create.
[180:27.04]Make some room. After line 10,
[180:30.24]we'll define an array of titles here
[180:32.56]that will populate the list. bar titles
[180:36.24]equals title preview titles. For now,
[180:41.20]our sample data works great.
[180:44.39]Go ahead and delete the famous hello
[180:46.00]world.
[180:48.31]Instead, type scroll view with braces.
[180:52.08]This screen will later return a list of
[180:53.92]titles from a search. Therefore, we want
[180:57.84]to scroll view in case the search
[180:59.84]results exceed the screen capacity.
[181:03.43]Inside the scroll view, type lazy v
[181:07.04]grid.
[181:08.56]Down arrow and right arrow to see more
[181:10.39]options. Select the option with columns
[181:13.12]and content.
[181:15.20]Lazy V-grid allows the items to stack
[181:17.35]vertically into columns. Lazy means this
[181:20.31]grid will load elements only when they
[181:22.39]are needed on screen.
[181:25.20]Columns is an array of grid items that
[181:28.39]define how many columns our grid has.
[181:31.60]For this grid, three is perfect. Meaning
[181:34.64]we need to add three grid items. Select
[181:37.43]grid item. Press enter. Add a set of
[181:41.04]parenthesis before the closing brace,
[181:44.16]comma, grid item, parenthesis, comma,
[181:49.12]grid item, parenthesis.
[181:54.31]We could have to find different spacings
[181:56.72]and other properties for the grid items.
[181:59.60]However, just a simple version is good
[182:02.88]for our needs.
[182:04.88]Tab over to content. Press enter to
[182:07.92]complete the closure.
[182:09.84]The content of our lazy V grid can go
[182:12.39]inside these braces
[182:14.56]or each open parenthesis titles
[182:19.76]close parenthesis
[182:21.68]bracket title in enter twice. This loops
[182:26.47]through our titles list and gives us
[182:28.88]access to each element.
[182:31.43]For each element, just the movie poster
[182:34.00]is good. Put your cursor inside the for
[182:36.72]each braces
[182:38.64]async image URL
[182:41.60]URL parenthesis string
[182:44.96]title poster path question mark question
[182:48.80]mark quotes.
[182:51.60]We convert the poster path string into a
[182:53.68]URL and also safely unwrap it. If it's
[182:57.43]nil, an empty string is passed.
[183:01.04]A placeholder is needed for our async
[183:02.96]image as it loads. Add an open brace at
[183:05.76]the end.
[183:07.60]Image in. Press enter a couple times.
[183:12.08]After the closing brace, place holder.
[183:15.27]Enter. Progress view.
[183:18.64]They show the progress circle while the
[183:20.80]image loads.
[183:22.88]Now we can add modifiers to our async
[183:24.80]image inside the braces. Image
[183:28.88]entertizable
[183:31.92]dots scale to fit
[183:34.80]dot clip shape
[183:37.92]rect
[183:39.43]parentheses corner radius
[183:42.80]10.
[183:44.80]These modifiers allow the image to
[183:47.04]resize into the lot space while keeping
[183:50.08]good aspect ratio and rounding the
[183:52.47]corners.
[183:54.24]To finish this off, we can add a frame
[183:57.04]for each of the images. Select the
[183:59.60]closing placeholder brace. Enter. Dot
[184:03.84]frame.
[184:05.92]Select the one with width and height.
[184:09.52]Width will be 120 points and height will
[184:12.72]be 200 points.
[184:14.96]This allows the images to only be within
[184:17.52]this frame.
[184:19.35]Our lazy V-grid is complete. We can
[184:21.92]scroll down on the list if more elements
[184:24.16]get populated.
[184:26.00]It's a shame our sample data only has
[184:27.76]three titles, so we can't see how the
[184:30.00]next row looks like. Don't worry, real
[184:33.12]data will populate here soon.
[184:36.39]We can run a quick test. Open up content
[184:39.60]view.
[184:41.84]Delete the text inside the search tab.
[184:47.20]Search view.
[184:51.68]Make sure your API config has the movie
[184:53.84]database key. Command R to run.
[185:03.20]Our simulator is up and running. Click
[185:05.68]on the search tab.
[185:08.72]We have the grid showing. That wraps up
[185:11.76]this video. Thank you so much for
[185:13.92]watching.
[185:16.08]There's a good chance you'll need a
[185:17.43]toolbar at some point in your app. It's
[185:20.16]perfect for storing buttons, setting a
[185:22.56]title, or even housing a search bar. In
[185:26.24]this video, we'll build a Swift UI
[185:28.47]toolbar and add simple logic to make it
[185:31.35]dynamic. We can start by adding a title
[185:34.31]first. For this feature, the main view
[185:37.35]needs to be inside a navigation stack.
[185:40.16]Inside search view, right click on
[185:42.31]scroll view, embed
[185:46.08]navigation
[185:48.00]stack.
[185:50.00]This is a great first step as we'll need
[185:52.24]navigation later for this view. The rule
[185:55.35]of thumb when adding a navigation title
[185:57.52]is to be as close to the navigation
[185:59.27]stack as possible. The closest we can
[186:02.00]get is after our scroll view. Find the
[186:04.64]scroll view closing brace. I'll scroll
[186:07.12]down. Press enter after the brace dot
[186:11.60]navigation title.
[186:15.52]It's tempting to hardcode the title in
[186:17.35]there. However, a good habit is to have
[186:20.39]the strings in one place where we can
[186:22.39]manage them better. It'll also make
[186:24.72]adding logic easier. Open
[186:27.27]constants.sswift.
[186:30.39]Make some space after the top rated TV
[186:32.47]string.
[186:34.72]static bl
[186:39.60]string equals quotes movie search.
[186:46.96]Make a new line static let TV search
[186:53.12]string equals quotes TV search.
[186:58.88]In our view, we'll be able to search for
[187:01.60]either a movie or TV show. Therefore, we
[187:05.76]want the title to change depending on
[187:07.92]what's selected.
[187:10.00]In addition, we'll also need two icons.
[187:13.43]Scroll down.
[187:15.35]Hit enter after the download icon
[187:17.27]string.
[187:18.88]Static lamp TV
[187:22.72]icon string equals quotes.
[187:27.04]Copy
[187:29.04]and paste it below.
[187:32.00]Change the second TV to movie.
[187:36.16]Click inside the TV icon string quotes.
[187:40.16]The SF symbol name goes inside here. I
[187:43.20]happen to know the name is just TV.
[187:47.12]Select inside the movie icon string
[187:49.12]quotes. Command shift L. The icon for
[187:53.35]movies is going to be the clapper that
[187:55.43]says we'll take their in. Search for
[187:57.76]clapper.
[187:59.35]Press enter and the SF symbol name gets
[188:02.24]filled out. A good trick if you ever
[188:04.56]need to search for SF symbols.
[188:07.52]Our strings and icons are ready. Go back
[188:09.92]to search view.sswift.
[188:12.80]Inside navigation title, put constants
[188:16.56]dot movie search string.
[188:23.92]The title looks good. We also need a
[188:26.64]button to toggle between a movie and TV
[188:28.96]search. Press enter after navigation
[188:31.52]title dot toolbar
[188:35.12]with braces.
[188:37.84]I'll scroll down.
[188:40.47]Inside the braces, we can define a tool
[188:43.92]bar item.
[188:46.24]Select the one that has placement and
[188:47.92]content.
[188:49.43]Placement is where the toolbar item will
[188:51.12]be. dot top bar trailing.
[188:56.39]This puts the item on the right of the
[188:58.39]bar. Tab over to content and press
[189:01.12]enter.
[189:02.64]Inside these braces, we can define
[189:04.96]what's in the toolbar. Type button with
[189:08.31]braces.
[189:09.84]After the closing brace label, press
[189:13.43]enter to autocomplete.
[189:15.92]Label lets us define how the button
[189:17.60]looks. In this case, the button will be
[189:20.39]an SF symbol.
[189:22.16]Type image
[189:24.08]system name
[189:26.64]constants dot movie icon string.
[189:32.00]Nice. We get the image on the top right.
[189:35.52]Our toolbar is looking good. We just
[189:37.84]need to add some logic. When the movie
[189:40.39]icon is tapped, the title and icon
[189:42.80]should switch to TV. For this, a new
[189:46.00]variable is needed. Scroll up.
[189:49.52]Make a new line after v titles
[189:53.20]at state
[189:55.52]private
[189:57.35]bar
[189:59.04]search by
[190:02.00]movies
[190:03.84]equals true.
[190:07.12]Add state allows a UI to change this
[190:09.04]variable. Private allows only this view
[190:11.92]to access the variable. Private isn't
[190:14.31]absolutely needed here, but it's good
[190:16.39]practice to keep everything scoped to
[190:18.47]what they need. With our new boolean, we
[190:22.08]can scroll down to the tobar item.
[190:25.12]Inside button, type search by movies
[190:29.60]toggle.
[190:31.52]Now, when the button is pressed, search
[190:33.68]by movies will go from true to false and
[190:36.16]vice versa.
[190:38.47]To finish the logic, we need both the
[190:40.96]navigation title and icon to depend on a
[190:44.00]boolean
[190:45.52]before constants that movie search
[190:47.27]string inside title
[190:49.84]search
[190:51.52]by movies question mark
[190:56.64]after constants dot movie search string
[191:01.35]colon constants.
[191:04.24]TV search string
[191:09.04]we use eternity operator where if search
[191:11.68]by movies is true then show the movie
[191:14.31]search string if it's false then show
[191:17.76]the TV search string for the navigation
[191:20.24]title
[191:22.47]copy the it turn itary operator logic
[191:26.47]paste it as a system name variable
[191:31.43]just use movie icon string
[191:37.27]and TV icon string.
[191:42.88]This completes the logic. We can test
[191:45.35]this inside our preview.
[191:51.12]Nice. Everything is in working order.
[191:54.56]This is a great place to stop. Our UI
[191:56.96]has an awesome toolbar and some logic to
[191:59.43]help in the later stages. Thank you for
[192:02.00]watching. I'll see you in the next one.
[192:05.68]Search bars are a common feature in iOS
[192:07.76]apps. They can help filter and organize
[192:10.96]data for the user. In this video, we'll
[192:14.56]add a search bar to our UI and construct
[192:17.20]the API search URL.
[192:19.84]To start off, we'll need new string
[192:22.24]constants for our search bar prompt
[192:24.24]text. This text will be displayed when
[192:27.12]the bar is empty. Open constants.
[192:31.60]Make a new line after TV search string
[192:35.27]static lat movie placeholder
[192:40.64]string equals quotes search for a movie.
[192:47.60]Copy and paste the line we just made.
[192:51.12]Switch out movie for TV.
[192:55.52]Search for a TV
[192:58.39]show.
[193:00.08]We'll need these two since we'll be
[193:02.08]switching between a movie search and TV
[193:04.47]search.
[193:06.08]Go back to search view.
[193:08.80]In addition to these new strings, we
[193:11.20]also need a variable to hold what the
[193:13.35]user searches. Make some space after
[193:16.08]line 12.
[193:18.56]at state private
[193:22.00]bar
[193:23.60]search text equals quotes
[193:28.39]at state allows a view to modify the
[193:30.31]variable. We use private because no
[193:33.52]other file will need to access this
[193:35.04]variable directly.
[193:37.20]All the precursors are ready. Scroll
[193:39.68]down and find the toolbar closing brace.
[193:44.23]Enter
[193:45.84]dot searchable.
[193:49.68]Choose the one with text and prompt.
[193:53.04]For text, we can put dollar sign search
[193:56.72]text.
[193:58.23]This creates a binding. Whatever the
[194:00.31]user types in the search bar gets synced
[194:03.12]into our search text variable. Tab over
[194:06.16]to prompt. Search by movies
[194:10.00]question mark constants
[194:12.80]dot movie placeholder string colon
[194:17.43]constants
[194:20.47]dot TV placeholder string.
[194:25.04]We see the turnary operator here
[194:27.52]allowing us to display the correct
[194:28.96]prompt depending on the type of search.
[194:32.23]Please update your API keys in
[194:34.47]APIconig.json.
[194:36.72]Press command R to run.
[194:42.64]Our app is up. Navigate to the search
[194:45.35]tab.
[194:47.04]Nice. Our search bar is showing. We can
[194:50.31]toggle it back and forth.
[194:55.52]Everything is working correctly.
[194:58.31]I do want to point out how easy it was
[195:00.56]to add the search bar thanks to Swift
[195:02.88]UI. In addition, we were able to use
[195:06.80]searchable because our view is inside a
[195:09.27]navigation stack.
[195:11.43]If we didn't use a navigation stack, for
[195:13.76]example, if we were in a sheet, then we
[195:17.20]would have to make the bar manually,
[195:19.35]which isn't too bad.
[195:21.60]We can get the bar rolling on hooking up
[195:23.84]the search bar to our API.
[195:26.31]A good place to start is to build the
[195:28.16]URL. Open data fetcher.
[195:32.47]I'll paste what a search call looks
[195:34.08]like.
[195:37.04]This one is a bit different than the
[195:38.88]rest of the URLs we've built so far. The
[195:41.92]word search is before the media type.
[195:44.72]And there are two queries, the API key
[195:48.08]and the movie or TV show we are
[195:49.84]searching. In this example, it's the
[195:52.96]movie Pulp Fiction.
[195:55.35]With this accounted for, we can scroll
[195:57.68]down to our build URL function.
[196:03.27]Click after the else if closing brace.
[196:06.56]Hit enter a couple times.
[196:09.12]Add else if type double equals quotes
[196:13.92]search with braces.
[196:17.68]Copy the path from the first else if
[196:19.76]statement.
[196:22.00]Paste it inside our second else if.
[196:25.43]Switch around type and media.
[196:31.60]I'll backspace else so it chains
[196:34.00]correctly.
[196:36.96]Admittedly, these chaining if statements
[196:39.76]aren't the prettiest. It would probably
[196:42.23]look better with a switch case
[196:44.16]statement. Maybe we'll go back and
[196:47.04]tighten up our code in a future video.
[196:50.56]To wrap up, we just need to handle our
[196:53.20]second query item for the search URL.
[196:56.80]In the arguments,
[196:58.80]add a comma after type
[197:01.52]search
[197:03.04]phrase colon string question mark equals
[197:08.08]nil.
[197:09.92]This argument is optional with a default
[197:12.64]value of nil allowing the function to be
[197:15.27]used without a search phrase.
[197:18.39]Scroll down before we make the URL.
[197:22.23]makes room before the guardlet
[197:23.76]statement.
[197:26.31]Bar URL query items equals brackets.
[197:34.16]Copy the API key query item
[197:38.80]and paste it inside our new array.
[197:43.27]Every API call needs this API key query
[197:45.84]item to work. Now we can add the second
[197:48.56]item only if search phrase isn't nil.
[197:51.76]Make some space if search phrase with
[197:56.31]braces URL query items append URL query
[198:01.84]item name and value name will be quotes
[198:06.00]query
[198:07.60]value will be search phrase.
[198:10.80]Now we can pass the new URL query items
[198:13.60]in our URL.
[198:18.96]This successfully puts the search query
[198:21.27]into our URL only if it's needed.
[198:24.47]Unfortunately, we can't see the search
[198:26.72]URL in action just yet, but we are
[198:29.27]getting closer to adding the feature.
[198:31.68]We'll continue the next video. Thank you
[198:34.16]for watching.
[198:36.00]View models in Swift UI are surprisingly
[198:38.23]controversial. That's because Swift UI
[198:40.88]was designed with state management baked
[198:43.04]right into the view. In my experience,
[198:46.39]as the app grows and networking calls
[198:48.64]come into play, view models can help
[198:51.04]manage responses and keep the UI
[198:53.35]focused. We already have a view model in
[198:56.31]our current app. However, this view
[198:59.12]model is working with the home title
[199:01.35]detail and upcoming screens. To keep
[199:04.80]things better organized, we can make a
[199:07.12]new one to just focus on the search
[199:09.35]screen. Hit command N. Swift file. Next.
[199:15.68]Search view model.
[199:19.12]Great.
[199:21.60]Like our first view model, this one also
[199:24.08]needs to observe changes to its
[199:25.60]properties and communicate them. To do
[199:28.39]this, we can type at observable
[199:32.00]class search view model with braces.
[199:36.39]We're using a class here because it's a
[199:38.47]reference type, meaning changes to its
[199:40.72]properties reflect everywhere it's used.
[199:44.16]We've used enums to keep track of the
[199:46.00]different fetching states so far in the
[199:48.16]course. For this view model, we'll keep
[199:51.04]it simple and start with an optional
[199:53.35]property in case an error occurs.
[199:56.47]private
[199:58.00]set
[200:00.00]bar error message colon string question
[200:04.96]mark
[200:06.64]private set allows only this file to set
[200:09.20]the value of error string while still
[200:11.60]allowing others to read it. We'll also
[200:14.56]need an array of titles to store the
[200:16.23]results.
[200:17.92]private
[200:19.52]set
[200:21.27]bar search titles colon bracket title
[200:29.04]equals empty brackets.
[200:32.39]Making the array empty ensures it's
[200:34.72]ready to use and won't need to be
[200:36.80]unwrapped later if something fails. The
[200:39.84]last property we need is an instance of
[200:41.76]our data fetcher to make the API calls.
[200:44.88]private let data fetcher
[200:49.20]equals data fetcher.
[200:53.27]It's completely private here as no other
[200:55.68]file will need access to it. Let is also
[200:58.64]used because it won't change. Our
[201:01.68]properties are ready. We can now make
[201:03.60]our function bunk get search titles
[201:09.68]by media colon string
[201:13.76]or title
[201:16.16]colon string
[201:18.39]async with braces.
[201:21.68]Media will change depending if you are
[201:23.52]in a TV search or movie search.
[201:26.96]Title is a search term the user will
[201:28.72]enter in the search bar.
[201:31.52]Async is used as this function will be
[201:33.52]making a network call. Inside our
[201:36.39]function, write a do catch block.
[201:41.52]Let's go reverse and fill out the catch
[201:43.52]block first. Print error
[201:47.92]error message equals error.lo
[201:52.39]description.
[201:54.47]This prints the error to our log and
[201:56.80]assigns a user friendly message to our
[201:58.64]error message. We'll display the error
[202:01.20]message in our UI later. Inside the dup
[202:04.64]block, error message equals nil.
[202:09.35]If title is empty,
[202:14.00]search titles equals try awaits
[202:19.04]data fetcher fetch titles for media by
[202:24.31]trending.
[202:26.08]We first clear out any error messages.
[202:29.20]Title is going to be what the user types
[202:31.20]into the search bar. If the search bar
[202:33.92]is empty, we'll return a trending list
[202:36.47]of movies or TV shows depending on what
[202:39.20]the user is searching. After the if
[202:41.92]statement, type else with braces. Before
[202:45.68]we can fill out this else statement, we
[202:47.76]do need to make an adjustment. Open data
[202:50.56]fetcher.
[202:52.80]Currently, our fetch titles function
[202:55.52]doesn't have a way to add a search term.
[202:58.08]We can fix this by adding another
[202:59.60]parameter. After string, add a comma
[203:03.27]with title colon string question mark
[203:07.20]equals nil.
[203:10.39]This creates an optional parameter
[203:11.84]called title and assigns nil if it's not
[203:14.72]used. Title will be how we pass our
[203:17.84]search term. With our new parameter, we
[203:21.20]just need to adjust the build URL call.
[203:24.23]Add a comma after type
[203:27.20]search phrase colon title.
[203:32.88]Our build URL function was made to
[203:35.27]complete the search URL only if search
[203:37.92]phrase is not new. With this adjustment,
[203:41.27]go back to search view model.
[203:44.88]Inside the else block, search titles
[203:48.16]equals try await data fetcher fetch
[203:53.35]titles for by width
[203:56.23]or will be the media pass in the
[203:57.92]arguments.
[203:59.60]We can pass search in for by
[204:03.27]width will be title.
[204:05.60]In hindsight, it would probably be
[204:07.84]better to group our parameters with
[204:09.27]enums. If you're working with a team,
[204:12.64]they most likely wouldn't know to pass
[204:14.23]in the string search or trending for the
[204:16.80]different API calls. Just some feedback
[204:19.68]for our own code. This completes our
[204:22.47]search view model. All that's left is to
[204:24.96]wire it up to the UI. We'll tackle this
[204:27.60]in the next video. Thank you for
[204:29.84]watching. Delaying an API call or
[204:32.47]debouncing is a great way to build an
[204:34.96]efficient search feature. Using this
[204:37.52]method can help prevent unnecessary
[204:39.27]requests every time user types. In this
[204:42.23]video, we'll demonstrate how to complete
[204:44.23]an async search bar using debouncing.
[204:47.76]With our view model ready, we can now
[204:50.16]hook it up to our view. Open search
[204:52.96]view.
[204:54.80]Make a new line after search text.
[204:57.92]Private blatant search view model equals
[205:03.68]search view model. This view model will
[205:07.27]hold our titles and error if there is
[205:09.68]one. Let's complete the search bar logic
[205:12.64]first. Scroll down.
[205:15.84]After searchable, add task. Select the
[205:20.08]one with ID and action.
[205:24.08]For ID, add search text.
[205:27.27]Tab. Press enter to complete the
[205:29.76]closure. This task modifier will rerun
[205:32.80]the task inside anytime search text
[205:35.35]changes. Search text is bound to the
[205:38.00]search bar. Therefore, anytime the user
[205:41.20]types, a new API search will trigger.
[205:44.80]Inside the code block, type try question
[205:47.76]mark08
[205:49.68]ask.
[205:51.92]4 milliseconds
[205:54.56]500. This adds half a second delay after
[205:58.39]the user stops typing. Without the
[206:01.20]delay, our API will get called after
[206:03.68]every keystroke, which isn't ideal. Make
[206:07.12]some space.
[206:08.88]If task is
[206:12.23]return
[206:14.08]here, we exit early if the task was
[206:16.64]cancelled to avoid running outdated
[206:18.96]searches. That can happen if the user
[206:21.60]keeps typing after stopping causing the
[206:24.31]text to change midtask.
[206:27.60]Now we can add our API call
[206:30.56]await search view model dot get search
[206:35.12]titles by search
[206:39.35]by movies
[206:41.52]question mark movie
[206:44.96]colon TV
[206:47.92]or search text. We use a wait because
[206:53.04]the function is asynchronous meaning it
[206:55.68]runs in the background.
[206:57.43]The call will look for either a movie or
[206:59.27]TV show depending on the mode with the
[207:02.23]search text.
[207:04.08]This completes our search bar logic. We
[207:06.96]also need to add the API call when
[207:09.20]toggling between a movie or TV search.
[207:12.23]Highlight and copy line 51.
[207:15.68]Scroll up to the trailing toolbar icon.
[207:19.20]Add a task block after toggling the
[207:21.20]boolean.
[207:23.52]Paste the API call in it.
[207:27.20]The task block allows us to call an
[207:28.96]asynchronous function inside a place
[207:31.27]that usually doesn't support a wait. In
[207:33.84]our case, inside a button tab.
[207:37.27]Just a couple of more things before we
[207:38.88]can test. Scroll up.
[207:42.16]Delete the titles inside for each.
[207:45.68]Replace instead with search view model
[207:49.84]search titles.
[207:51.84]We can use these titles as they will get
[207:54.16]populated with our API calls. Don't
[207:57.04]forget to delete the titles property as
[207:59.60]our sample data is no longer needed.
[208:03.27]The last thing is to display our error
[208:05.35]if one happens. The best place to have
[208:08.16]this error is right before lazy B grid
[208:11.20]inside the scroll view. Add a couple
[208:13.84]lines before then.
[208:16.96]If let error equals search view model
[208:22.47]dot error message
[208:25.20]inside the braces text error
[208:29.92]dot foreground style
[208:33.20]red
[208:34.88]padding
[208:37.20]dot background
[208:41.04]dot ultra then materialclipip
[208:45.60]shape
[208:48.47]direct
[208:51.84]corner radius
[208:54.23]10. We added some styling to our error
[208:57.20]text. If let is great here, as if no
[209:00.80]error exists, the view will get drawn
[209:02.96]like normal. That completes this view
[209:05.84]and we're ready to test. Please update
[209:08.39]your API keys inside APIconfig.json JSON
[209:11.76]and hit command R.
[209:17.27]Our app is up and running. Click on the
[209:19.68]search tab.
[209:22.64]Nice. Our grade view populates with
[209:24.88]default titles. I'll try to search Harry
[209:27.76]Potter.
[209:34.00]Good stuff.
[209:35.92]Let's cancel.
[209:38.47]and some default movies pop back up.
[209:41.60]Toggle for a TV show.
[209:45.60]Harry Potter
[209:48.72]now returns TV shows.
[209:51.43]I'll search instead for one of my
[209:53.52]favorite TV shows,
[209:55.68]Breaking Bad.
[209:58.96]There it is. I do want to show how the
[210:01.52]error looks like offscreen. I'll delete
[210:05.12]the movie database API key and run the
[210:08.16]app again.
[210:12.00]The app is back up with no API key and
[210:14.64]we have an error on the home tab. We
[210:17.52]didn't install this error and it shows
[210:20.96]navigating to search.
[210:23.84]The error looks much better here. It
[210:26.47]scrolls up and down with our view.
[210:30.64]I do want to talk about some ways this
[210:32.39]screen can improve. To wrap up, if we
[210:35.84]search for something that doesn't give
[210:37.12]results, an error saying no search
[210:39.43]results would be nice. In addition, a
[210:43.68]default image when the titles don't load
[210:46.16]would be better. Right now, we just have
[210:49.60]a progress circle that doesn't stop
[210:51.84]spinning when this happens.
[210:55.27]We won't be adding these features, but
[210:57.52]if you want to try, please feel free.
[211:01.04]Navigation is all that's left to finish
[211:02.88]this section and that will be the topic
[211:05.20]of the next video. Thank you for
[211:07.43]watching.
[211:09.35]Our search screen is looking great, but
[211:11.60]still needs navigation to be complete.
[211:14.16]We've seen how to use both navigation
[211:15.92]path and navigation link to complete
[211:18.16]this. Out of the two, let's use
[211:21.20]navigation path for this screen.
[211:23.60]Navigation links are easier but come
[211:25.92]with performance issues. If you're just
[211:28.56]joining us, the starter code for this
[211:30.72]video is in the description.
[211:33.68]Let's start in search view.
[211:36.39]Make a new line after search view model
[211:39.76]at state private
[211:43.27]bar
[211:45.27]navigation path equals navigation
[211:50.96]path.
[211:53.04]This variable will allow the view to
[211:54.64]track and control navigation history.
[211:58.16]Inside navigation stack, add parenthesis
[212:02.08]path colon dollar sign navigation path.
[212:07.35]This binds the stack's navigation state
[212:09.60]to our navigation path, letting us push
[212:12.47]and display views.
[212:14.96]Scrolling down,
[212:17.43]we need to append a title to our
[212:19.04]navigation path when it's clicked. One
[212:22.00]way is to add a tap gesture to our async
[212:24.23]image. Make a new line after frame
[212:28.64]dot on tap gesture.
[212:32.47]Navigation
[212:34.47]path append
[212:37.60]title.
[212:39.68]We just need to tell the path where to
[212:41.35]go when there's a title object.
[212:43.68]Scrolling further down,
[212:47.04]make a new line after task
[212:50.23]dot Navigation destination or
[212:54.16]destination
[212:56.00]in four type title self
[213:00.08]tab. Press enter to complete the
[213:02.56]closure.
[213:04.72]The closure variable can be title
[213:07.52]inside the braces title detail view
[213:11.92]title title.
[213:13.84]When the title strruct is passed into
[213:15.84]our navigation path, the view will
[213:18.23]navigate to title detail view passing in
[213:21.12]the tab title. We're ready to run.
[213:24.96]Please update your API keys for the
[213:26.80]movie database and the YouTube API
[213:29.20]inside API config.json.
[213:32.00]Press command R to run.
[213:37.76]Our app is running. Navigate to search.
[213:42.88]Click on the title.
[213:47.76]Perfect. Our title detail screen is
[213:50.08]working.
[213:51.76]This completes the search screen. To
[213:54.39]wrap up, I would like to add a button to
[213:57.12]the title detail screen for the final
[213:59.52]section.
[214:01.12]Open title detail view.
[214:05.20]Make some room after title overview
[214:09.27]button with braces.
[214:12.08]label
[214:13.60]inside label text
[214:16.00]constants dot download string dot ghost
[214:20.08]button.
[214:21.76]We'll just keep the same button style
[214:23.52]already made earlier.
[214:25.92]I do want the button to be in the middle
[214:27.68]of the screen. Before the button,
[214:31.35]type hstack with braces.
[214:35.12]Go to spacers.
[214:39.43]Cut the button
[214:41.43]and paste it in between.
[214:43.92]This will center the button. Press
[214:46.47]command R to run.
[214:51.84]App is running. Click on any title
[214:58.16]and our button is showing correctly.
[215:01.68]This completes our async search bar.
[215:04.47]We've come a long way with this app and
[215:06.88]I want to thank you all for the support
[215:08.47]throughout this journey. I'll see you in
[215:10.96]the final section. Swift Data.
[215:14.80]Swift Data is Apple's modern framework
[215:17.04]for managing data offline. It's
[215:19.68]efficient, lightweight, and easy to use.
[215:23.20]In our app so far, we display data
[215:25.84]primarily from the movie database API.
[215:29.52]The goal in this section is to save and
[215:32.00]delete titles in the download tab. If
[215:34.96]you're just joining us, the starting
[215:36.96]code is in the description so you can
[215:39.04]code along. The first step in this
[215:41.52]journey is to get our title model swift
[215:43.68]data ready. Starting in title.sswift,
[215:47.43]we can replace import foundation with
[215:50.08]swift data.
[215:52.23]Foundation wasn't used in this file and
[215:54.64]the swift data import allows us access
[215:56.96]to the library.
[215:58.96]The tile strct is what will be saved in
[216:00.96]our data. Therefore, it needs to be
[216:03.84]marked with at model.
[216:07.84]To properly use this macro, change
[216:10.16]strruct to class.
[216:13.60]At model converts a swift class into a
[216:16.88]stored model that's managed by Swift
[216:19.12]data. There are a few errors that happen
[216:21.76]with this change. The first of which is
[216:24.31]because in it isn't used. Make some room
[216:27.12]after the poster path property. Type in
[216:30.08]it and press enter to autocomplete.
[216:34.23]Adding init tells Swift Data exactly how
[216:36.39]to create our class from scratch.
[216:38.80]Without it, Swift data can't properly
[216:41.27]initialize all sort properties when
[216:43.68]loading the model from storage.
[216:46.31]The next error is because our model
[216:48.00]isn't conforming to the decodable
[216:49.68]protocol. Scroll down.
[216:53.04]Add a couple of new lines after in it.
[216:56.08]Required in it.
[216:59.20]Wait a few seconds and autocomplete if
[217:01.60]it adds a decoder.
[217:03.92]Required in it tellswift data how to
[217:05.92]create our model from the decoded JSON
[217:08.56]data. Since we also change the strct to
[217:11.68]a class, required init make sure any
[217:14.56]subclass can be decoded the same way.
[217:17.04]Before we complete the required init
[217:18.96]function, coding keys are needed to
[217:21.43]properly match the JSON's object
[217:23.43]property to ours. Right above required
[217:26.39]in it, make some space enum coding keys
[217:32.00]colon coding key with braces. inside
[217:36.23]coding keys. Case ID, case title,
[217:41.52]case name,
[217:43.84]case overview,
[217:46.39]case poster path inside required init
[217:51.60]let container equals try
[217:56.00]decoder.container
[217:58.80]keyed by holding keys do self. This line
[218:02.88]creates a container that lets us access
[218:05.20]the JSON data using the keys defined
[218:08.23]encoding keys. Now that we have our
[218:10.80]container, we can try to decode and
[218:13.68]initialize our properties.
[218:16.39]ID equals try container.deode
[218:20.96]if present int self
[218:25.20]or key do ID. All our properties are
[218:28.72]optionals because there might be a
[218:30.72]chance the server data returns nil. In
[218:33.76]this case, I found decode if present is
[218:36.56]a safe way to continue. We just need to
[218:38.96]complete this for the rest of our
[218:40.23]properties.
[218:41.92]Title equals try container
[218:46.80]decode if present string self for
[218:50.00]key.title.
[218:52.08]Copy this line
[218:54.47]and paste it three times. One, two,
[218:58.23]three. Replace the rest of the
[219:00.72]properties.
[219:02.64]Name
[219:04.16]dot name
[219:07.76]overview
[219:11.12]dot overview
[219:14.47]and poster path.poster
[219:19.04]path.
[219:20.96]Our model is Swift Data ready. The final
[219:23.84]step is to add a model container to our
[219:25.84]app. Open blossom app.sswift.
[219:30.08]At the top,
[219:32.31]import swift data after the window group
[219:36.16]closing brace
[219:38.39]model container
[219:40.80]or title.
[219:45.20]This creates a Swift data container that
[219:47.60]knows how to store and manage title
[219:49.43]objects. It'll handle saving, loading,
[219:53.20]and keeping our model data in sync with
[219:55.20]the database. With this, our model is
[219:58.39]ready. We'll put it to use in the next
[220:01.04]one. Thank you for watching.
[220:04.00]Saving and displaying data is a critical
[220:06.31]step for any app managing data. Lucky
[220:09.27]for us iOS developers, Swift Data makes
[220:12.16]these actions very simple. We'll
[220:14.56]showcase this in today's video.
[220:17.52]There are two places we can save titles
[220:19.52]in the app. The first is the download
[220:21.84]button in our home tab. That's a good
[220:24.47]place to start. Open home view.
[220:28.56]Make a new line after title detail path.
[220:32.23]Type at environment
[220:35.27]parenthesis backslash dom
[220:38.96]context var model context.
[220:43.35]This grabs our connection to Swift data.
[220:45.92]With it, we can insert, delete, and save
[220:49.43]data anywhere in this view. Scroll down
[220:52.00]to our download button.
[220:55.68]Inside the braces, add model
[220:58.00]context.insert
[221:01.12]view model hertitle.
[221:04.47]Try question mark model context.save.
[221:08.56]Here we insert the hero title into Swift
[221:11.12]data and then try to save it. Adding
[221:14.16]some kind of feedback would be a good
[221:15.60]idea, but this works for now. The second
[221:18.47]place we save is inside our title detail
[221:20.96]view. Let's navigate there.
[221:24.72]Make a new line after view model
[221:27.68]at environment
[221:30.39]backslash.model context
[221:33.35]bar model context. Before we write the
[221:36.72]save logic, it's important to think
[221:39.04]about how our API data is structured.
[221:41.68]The movie database API has both movies
[221:44.56]and TV shows. For movies, it uses the
[221:48.23]property title. As for TV shows, it uses
[221:51.76]a property name. That's why we include
[221:54.00]the title name competed property in this
[221:56.08]view. It checks which property isn't nil
[221:59.35]and returns it. With this in mind, we
[222:02.64]shouldn't save the title to our database
[222:04.80]as is. This can result in a database
[222:07.76]where the name can be in two places.
[222:10.23]When we try to sort, a nightmare can
[222:12.64]occur. A simple solution is to modify
[222:15.52]the data before saving it. Scroll down
[222:18.31]to the download button.
[222:21.52]Inside the braces, type let save title
[222:25.68]equals title.
[222:28.23]Save title.title title equals title name
[222:33.04]model context.insert
[222:36.00]save title
[222:38.08]try question mark model context.s save
[222:42.08]by putting the title name and title. We
[222:44.64]make sure the title is in one place.
[222:47.04]It's odd to see that let was used
[222:48.72]instead of bar here. Remember that title
[222:52.16]is now a class not a strruct. Let only
[222:55.43]locks the reference, but the properties
[222:57.60]inside are still mutable. Therefore, let
[223:01.04]is okay here. It's worth mentioning that
[223:03.35]this wasn't needed in the hero title
[223:05.27]save. That's because hero title will
[223:07.84]only show different movies. As we
[223:10.39]discussed, movies already have their
[223:12.56]name in title. The save feature is
[223:15.12]complete. Before testing, we need to
[223:18.00]display the data saved. Let's make the
[223:20.47]last file of this project with command
[223:22.23]N. Swift UI view. Next.
[223:27.04]Download view. Create.
[223:32.56]After import Swift UI, add import Swift
[223:36.47]data. Make some space before the body
[223:41.04]at query
[223:43.19]bar saved titles colon bracket title.
[223:49.60]This line tells Swift that fetch all the
[223:51.68]saved titles. It also updates the list
[223:54.72]automatically whenever the database
[223:56.88]changes. Inside the body, we can delete
[224:00.16]hello world. Add a navigation stack.
[224:06.72]Then a quick logic check. If save titles
[224:10.23]that is empty text
[224:14.23]no down loads
[224:18.31]padding
[224:20.72]dot font
[224:23.43]title 3bold.
[224:28.39]It's a good idea to display some kind of
[224:30.23]message if the list is empty. That way
[224:33.92]the user doesn't just see an empty
[224:35.60]screen. Add an else after the if
[224:38.23]statement.
[224:40.00]We'll reuse our vertical list view
[224:43.04]to display the save titles.
[224:45.76]One more thing before we test open
[224:47.92]content view.
[224:50.72]Replace download string with download
[224:53.04]view.
[224:57.19]Please update both your API keys for the
[224:59.92]movie database and the YouTube APIs in
[225:03.19]API config.json.
[225:05.68]Press command R to run.
[225:10.56]Our app is up and running. Navigate to
[225:13.04]download.
[225:15.12]The empty list message is showing
[225:17.19]correctly. Go back to the home tab.
[225:20.64]Press download on the hero title.
[225:23.68]Back to download
[225:26.00]and our title is showing because we
[225:28.88]reused the vertical list view.
[225:31.19]Navigation is already included. Let's go
[225:34.08]back home and select the trending movie.
[225:39.27]Download that one.
[225:41.68]Back to download.
[225:44.00]All good. Everything is working so far.
[225:47.43]There are a few things left to do, like
[225:49.60]being able to delete, not allowing
[225:52.08]duplicates, and sorting. We'll tackle
[225:55.35]all that in the next video. Thank you
[225:57.68]for watching. Deleting data is just as
[226:00.56]important as saving in any app. Users
[226:03.43]will most likely have data that they'll
[226:05.52]want to delete at some point. Swift data
[226:08.39]makes this action insanely easy. In this
[226:11.27]video, we'll demonstrate how we can
[226:13.04]accomplish deleting as well as sorting
[226:15.27]in Swift Data. I would like to keep
[226:17.60]things Apple native and have the delete
[226:19.92]button as a list swipe action. Let's
[226:22.88]open a vertical list view to get
[226:24.72]started.
[226:26.47]We have to remember that this view is
[226:28.23]used for both our downloads list and
[226:30.31]upcoming movies list. This is important
[226:33.19]because we don't want to allow the swipe
[226:34.80]action in the upcoming list. To help
[226:37.60]keep things separated, we can add
[226:39.68]another property. Make a new line after
[226:42.08]titles. Let can delete colon bull. When
[226:47.84]this view is called, we can set can
[226:50.56]delete to true or false. Helping us with
[226:52.72]our logic. We also need the model
[226:55.27]context to make changes to our database
[226:58.56]at environment
[227:01.35]parenthesis backslash domod context
[227:05.84]bar model context
[227:08.39]before moving on. Scroll down to fix the
[227:10.96]error.
[227:14.64]Set the preview boolean to true.
[227:18.16]Scrolling back up after the label
[227:20.88]closing brace, add dot swipe actions,
[227:24.96]select the one with edge and content.
[227:28.08]Dot swipe actions allows us to define an
[227:30.88]edge either leading or trailing. Leading
[227:34.00]will show at the front of the items
[227:36.31]trailing at the end. For this action, go
[227:39.19]ahead and put trailing. Tab over and hit
[227:42.47]enter. I'll scroll down a bit. Inside
[227:45.92]our code block, we can first check if
[227:48.16]deleting is allowed. If can delete with
[227:52.00]braces
[227:53.52]inside here, make a button
[227:56.88]with a label.
[228:00.00]Our label will be image system name with
[228:03.84]quotes. Inside the quotes, hit command
[228:06.72]shift L. Look up trash. Choose the first
[228:10.56]one.
[228:12.08]Add a tint modifier.
[228:15.35]Let's make it red. So far so good.
[228:18.96]Inside the put in logic, we need to
[228:21.19]delete the title. Model context dodelete
[228:26.16]title
[228:28.39]try question mark model context.save.
[228:33.12]This completes our swiping logic. There
[228:35.76]are a few errors to address before
[228:38.08]testing. Open upcoming view.
[228:41.84]Click on the error. Fix
[228:45.92]false.
[228:47.76]Lastly, go to download view.
[228:51.27]Click on the error.
[228:54.00]True.
[228:56.31]Please update your API keys inside API
[228:59.19]config.json.
[229:00.88]Hit command R to run.
[229:06.00]Our simulator is up. Click on download.
[229:09.76]Swipe the first title.
[229:13.60]It looks like I accidentally put the
[229:15.19]swipe action on leading. Easy fix. Go to
[229:18.80]a vertical list view.
[229:21.76]There it is. Switch it to trailing.
[229:25.60]Rerun the app.
[229:31.19]We're back. My apologies. Let's go to
[229:34.47]download.
[229:36.31]Swipe to delete the first item.
[229:39.52]Close the app.
[229:41.27]Reopen
[229:43.92]back to download.
[229:46.00]Looks good. We do need to check our
[229:48.47]upcoming tab.
[229:50.47]Try to swipe.
[229:53.12]Nice. We're not able to. Just a couple
[229:56.96]of more things left. I would like no
[229:59.52]duplicate titles in our data. That's an
[230:02.39]easy change. Open title.swift.
[230:06.72]before v id type
[230:10.16]at attribute
[230:13.19]dot unique.
[230:16.23]This macro makes sure that each title
[230:18.00]saved in swift data has a unique ID.
[230:20.80]Therefore, if two titles have the same
[230:23.12]ID, saving won't be allowed, preventing
[230:26.00]duplicates.
[230:28.08]I would also like to sort the list in
[230:29.76]alphabetical order. For this, open
[230:33.04]download view.
[230:35.27]Add a parenthesy after query
[230:38.80]sort colon backs slashtitle.title.
[230:44.16]This macro will sort our swift data
[230:45.84]titles alphabetically by the title
[230:48.08]property. Remember when we save our
[230:51.19]titles we make sure all names go into
[230:53.92]the title property. Let's run this code
[230:56.47]and test it.
[231:00.96]Our simulator is up. Try to save the
[231:03.68]hero title a few times.
[231:08.31]Go to download and it only saved once
[231:12.72]in home. Download a few titles so we can
[231:15.52]test the sorting.
[231:20.08]Get some TV shows.
[231:24.31]One more TV show.
[231:29.35]Back to download.
[231:33.52]Looks like it's in working order. We're
[231:36.00]all set with these features. There is a
[231:38.56]small bug left in the app. We'll tackle
[231:40.96]it in the next one. Thank you for
[231:42.96]watching. Bugs are a natural part of
[231:45.27]development. Where there's code, bugs
[231:47.92]can and will appear. We combat this by
[231:50.88]testing our apps and trying to catch
[231:53.19]bugs before production. At this stage,
[231:56.64]our app has all the features we wanted
[231:58.39]to add. However, if we go to the
[232:01.60]upcoming tab, click on the first title,
[232:06.39]download,
[232:08.56]the screen goes white. It's important to
[232:11.27]note this bug only happens on the
[232:13.43]upcoming and download tab. The common
[232:16.64]denominator of these tabs is that they
[232:19.04]were made with navigation links instead
[232:21.27]of navigation paths. Another reason not
[232:24.08]to use navigation links in production.
[232:27.19]The best solution is to rewire our
[232:29.84]upcoming and download tabs to use paths.
[232:33.35]We have seen this a few times in the
[232:34.96]course already. I challenge you to do
[232:37.35]this on your own and test your skills.
[232:40.39]Use search view as a guide. For our
[232:43.43]purposes, when the double button is
[232:45.68]pressed, we'll dismiss the detail
[232:47.76]screen. This is definitely a workaround
[232:50.16]to show different options, but using
[232:52.64]navigation paths is a true solution. To
[232:56.16]start, open title detail view.
[232:59.84]Make some space before the title
[233:01.27]property
[233:03.76]at environment
[233:06.39]open parentheses backslash.ismiss
[233:10.72]bar dismiss.
[233:13.04]This property provides access to the
[233:15.43]current views dismiss action. We can
[233:18.39]call dismiss to culture sheet or
[233:21.04]navigation destination when needed.
[233:24.16]We'll place this in our download button
[233:26.31]after everything saves. Scroll down.
[233:31.52]After model context.save,
[233:34.39]dismiss.
[233:37.19]Please update your API keys in
[233:39.19]APIcon.json.
[233:41.35]Press command R to run.
[233:48.64]Our simulator is up and running. Go to
[233:51.27]upcoming.
[233:53.35]Click on the second title.
[233:56.80]Download.
[233:59.19]Nice. No more white screen. To finish
[234:02.80]off the iOS 18 version of this app, I
[234:05.92]want to display errors better. Please
[234:08.47]remove the API keys and rerun the app.
[234:16.88]The simulator is up and as you can see,
[234:19.84]the home screen error is real sloppy.
[234:22.56]Going into the search tab,
[234:25.84]it looks much better.
[234:28.47]Let's have all our errors look like
[234:30.08]this. Inside Xcode, open search view.
[234:35.27]Copy the modifiers on our error text.
[234:39.52]Open constants.
[234:42.31]Scroll down.
[234:45.27]Paste the modifiers at the end for now.
[234:49.19]Copy and paste the ghost button
[234:50.64]extension.
[234:55.19]Rename the second one
[234:58.00]error message.
[235:01.52]Get the modifiers and paste them inside
[235:04.47]error message.
[235:10.16]With our new extension, we can go to
[235:12.64]home view.
[235:15.19]Scroll down to our error case.
[235:19.35]Delete everything inside text.
[235:23.43]Type error.loicalize
[235:25.52]description
[235:27.27]and at the dot error message modifier.
[235:32.23]I would like this error to be at the
[235:33.92]center of the screen. We use our
[235:36.23]geometry reader for the progress view
[235:37.76]last time. Scroll up to the progress
[235:40.47]case.
[235:42.56]Copy the frame modifier.
[235:45.60]Scroll back down.
[235:48.56]Paste it after the error message
[235:50.00]modifier.
[235:52.39]Before moving on, copy both modifiers.
[235:57.12]Open title detail view.
[236:00.64]Paste the modifiers on the error.
[236:05.84]Replace gio with geometry.
[236:12.96]We just need upcoming view.
[236:16.47]Same thing with the modifiers.
[236:21.52]That should be good. Please run the
[236:23.76]project.
[236:30.08]The errors look so much better. That
[236:32.80]completes the iOS 18 version of this app
[236:35.60]and the course. I want to thank you all
[236:38.23]for the support. We're going to take a
[236:40.56]break from YouTube and work on our first
[236:42.88]paid course. It's going to only use
[236:45.52]Swift data and Swift UI to keep things
[236:48.00]lean and fast. Thank you again and I'll
[236:51.43]see you in the next one.